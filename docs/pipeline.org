#+begin_src emacs-lisp :results silent :tangle no
(setq org-babel-post-tangle-hook nil)
#+end_src

#+begin_src emacs-lisp :results silent :tangle no
  (defun re-root (new_directory bfn)
    (let (
          (fnd  (->
                 bfn file-name-directory
                 directory-file-name
                 file-name-nondirectory
                 file-name-as-directory))
          )
      (concat (file-name-as-directory new_directory) fnd (file-name-nondirectory bfn))))


  (add-hook 'org-babel-post-tangle-hook
            (lambda ()
              (let (
                    (new-root (re-root "/ssh:gardner:/gpfs/data/xhe-lab/software/ldsc/" buffer-file-name))
                    )
                (message "Copying file: %s to %s" buffer-file-name new-root)                
                (copy-file buffer-file-name new-root t)
                (message "Copied file: %s to %s" buffer-file-name new-root)                
                )))


#+end_src

* Nature Communications submission notes
** Figure sizes
189 mm width  or 89 mm width
** Min font size 
8
** Other notes
Make sure to minimize whitespace


* Cluster configuration

I start off by defining some absolute directories that will be referred to throughout the script.  

#+BEGIN_SRC yaml :tangle ../workflow/config_base.yaml
  ---
  flag_file: &hst !Host {options: {midway2: "/project2", gardner: "/gpfs/data/xhe-lab/", desktop: "/run/media/nwknoblauch/Data"} }
  paths: 
    'DL': &dl  !Dep {host: *hst, pref:  null, path: { midway2: "/project2/xinhe/", gardner: "/gpfs/data/xhe-lab/", desktop: "/run/media/nwknoblauch/Data/"}}
    '1KG':     !Dep {host: *hst, pref: *dl, path: {midway2: &1kg "1kg/", gardner: *1kg , desktop: *1kg} }
    'OBERF':    !Dep {host: *hst, pref: *dl, path: {midway2: "missing_file", gardner: 'Ober/'} }
    'BED':     !Dep {host: *hst, pref: *dl, path: {midway2: &bed "genomic_annotation/ptb_epigenetic/", gardner: *bed, desktop: "ptb_scratch/new_bed/"}}
    'L2':      !Dep {host: *hst, pref: *dl, path: {midway2: &l2 "genomic_annotation/L2/", gardner: *l2, desktop: "L2/"}}
    'ANNO':    !Dep {host: *hst, pref: *dl, path: {midway2: "nwknoblauch/torus_annotations", gardner: "genomic_annotation/torus_annotations", desktop: "genomic_annotation/torus_annotations"}}
    'FINEMAP': !Dep {host: *hst, pref: *dl, path: {midway2: "nwknoblauch/susie_finemapping", gardner: "genomic_annotation/susie_finemapping", desktop: "genomic_annotation/susie_finemapping"}}
    'WEIGHTS': !Dep {host: *hst, pref: *dl, path: {midway2: &weight "1kg/1000G_Phase3_weights_hm3_no_MHC/", gardner: *weight, desktop: *weight}} 
    'FRQF':    !Dep {host: *hst, pref: *dl, path: {midway2: &frq "1kg/1000G_Phase3_frq/", gardner: *frq, desktop: "1kg/1000G_Phase3_frq/"}} 
    'GWAS':    !Dep {host: *hst, pref: *dl, path: {midway2: &gwas "ptb/", gardner: *gwas, desktop: "gwas_data/gwas_sumstats/"}}
    'LDSC':    !Dep {host: *hst, pref: null, path: {midway2: &ldsc "module load /home/nwknoblauch/spack_modules/ldsc/1.0.3; ", gardner: "/gpfs/data/xhe-lab/software/py-ldsc/bin/", desktop: ""}}
  envs:
    'r':    !Dep {host: *hst, pref:  null, path: { midway2: null, gardner: null, desktop: null }}
    'ldsc': !Dep {host: *hst, pref:  null, path: { midway2: null, gardner: null, desktop: "../envs/ldsc.yml" }}
    'cmd_prefix': !Dep {host: *hst, pref:  null, path: { midway2: "", gardner: "", desktop: "" }}
#+END_SRC

** Config :noexport:

#+BEGIN_SRC R :tangle ../scripts/parse_yaml.R

  config_basef <- "../workflow/config_base.yaml"
  annotf <- "../workflow/annots.yaml"

  host_fun <- function(x) {
    xo <- x$options
    for (n in names(xo)) {
      if (fs::dir_exists(xo[[n]])) {
        return(n)
      }
    }
  }

  dep_fun <- function(x) {
    if (is.null(x$pref)) 
      return(x$path[[x$host]])
    return(fs::path(x$pref,x$path[[x$host]]))
  }

  handler_l <- list(
    Host = host_fun,
    Dep = dep_fun
  )

  config <- yaml::read_yaml(
                      config_basef,
                    handlers =  handler_l)
  config_d <- config$paths
  annot <- yaml::read_yaml(annotf)
#+END_SRC


#+BEGIN_SRC yaml :tangle ../workflow/cluster_config.yaml
  ---
  __default__:
    partition: 'broadwl'
    time: '01:00:00'
    nodes: '1'
    ntasks: '1'
    cpuspertask: '1'
    output: "output/{rule}.{wildcards}.txt"
    error: "error/{rule}.{wildcards}.txt"
    export: "ALL"
    mem: '25G'
  anno2torus_fdr:
    mem: '45G'
  run_ldsc:
    mem: '45gb'
    time: '02:00:00'
  run_fastqtl_region:
    mem: '3gb'
    time: '00:30:00'
#+END_SRC


#+BEGIN_SRC  R :results output
  library(ldmap)
  library(tidyverse)
  lddf <- tibble::enframe(ldetect_EUR) %>%
    explode_ldmap_region() %>% mutate(chrom = as.integer(chrom))
  jsonlite::toJSON(lddf)

#+END_SRC

#+BEGIN_SRC yaml :tangle ../workflow/base_model.yaml
  - 'Coding_UCSCL2'
  - 'Coding_UCSC.flanking.500L2'
  - 'Conserved_LindbladTohL2'
  - 'Conserved_LindbladToh.flanking.500L2'
  - 'CTCF_HoffmanL2'
  - 'CTCF_Hoffman.flanking.500L2'
  - 'DGF_ENCODEL2'
  - 'DGF_ENCODE.flanking.500L2'
  - 'DHS_peaks_TrynkaL2'
  - 'DHS_TrynkaL2'
  - 'DHS_Trynka.flanking.500L2'
  - 'Enhancer_AnderssonL2'
  - 'Enhancer_Andersson.flanking.500L2'
  - 'Enhancer_HoffmanL2'
  - 'Enhancer_Hoffman.flanking.500L2'
  - 'FetalDHS_TrynkaL2'
  - 'FetalDHS_Trynka.flanking.500L2'
  - 'H3K27ac_HniszL2'
  - 'H3K27ac_Hnisz.flanking.500L2'
  - 'H3K27ac_PGC2L2'
  - 'H3K27ac_PGC2.flanking.500L2'
  - 'H3K4me1_peaks_TrynkaL2'
  - 'H3K4me1_TrynkaL2'
  - 'H3K4me1_Trynka.flanking.500L2'
  - 'H3K4me3_peaks_TrynkaL2'
  - 'H3K4me3_TrynkaL2'
  - 'H3K4me3_Trynka.flanking.500L2'
  - 'H3K9ac_peaks_TrynkaL2'
  - 'H3K9ac_TrynkaL2'
  - 'H3K9ac_Trynka.flanking.500L2'
  - 'Intron_UCSCL2'
  - 'Intron_UCSC.flanking.500L2'
  - 'PromoterFlanking_HoffmanL2'
  - 'PromoterFlanking_Hoffman.flanking.500L2'
  - 'Promoter_UCSCL2'
  - 'Promoter_UCSC.flanking.500L2'
  - 'Repressed_HoffmanL2'
  - 'Repressed_Hoffman.flanking.500L2'
  - 'SuperEnhancer_HniszL2'
  - 'SuperEnhancer_Hnisz.flanking.500L2'
  - 'TFBS_ENCODEL2'
  - 'TFBS_ENCODE.flanking.500L2'
  - 'Transcr_HoffmanL2'
  - 'Transcr_Hoffman.flanking.500L2'
  - 'TSS_HoffmanL2'
  - 'TSS_Hoffman.flanking.500L2'
  - 'UTR_3_UCSCL2'
  - 'UTR_3_UCSC.flanking.500L2'
  - 'UTR_5_UCSCL2'
  - 'UTR_5_UCSC.flanking.500L2'
  - 'WeakEnhancer_HoffmanL2'
  - 'WeakEnhancer_Hoffman.flanking.500L2'
  - 'GERP.NSL2'
  - 'GERP.RSsup4L2'
  - 'MAFbin1L2'
  - 'MAFbin2L2'
  - 'MAFbin3L2'
  - 'MAFbin4L2'
  - 'MAFbin5L2'
  - 'MAFbin6L2'
  - 'MAFbin7L2'
  - 'MAFbin8L2'
  - 'MAFbin9L2'
  - 'MAFbin10L2'
  - 'MAF_Adj_Predicted_Allele_AgeL2'
  - 'MAF_Adj_LLD_AFRL2'
  - 'Recomb_Rate_10kbL2'
  - 'Nucleotide_Diversity_10kbL2'
  - 'Backgrd_Selection_StatL2'
  - 'CpG_Content_50kbL2'
  - 'MAF_Adj_ASMCL2'
  - 'GTEx_eQTL_MaxCPPL2'
  - 'BLUEPRINT_H3K27acQTL_MaxCPPL2'
  - 'BLUEPRINT_H3K4me1QTL_MaxCPPL2'
  - 'BLUEPRINT_DNA_methylation_MaxCPPL2'
  - 'synonymousL2'
  - 'non_synonymousL2'
  - 'Conserved_Vertebrate_phastCons46wayL2'
  - 'Conserved_Vertebrate_phastCons46way.flanking.500L2'
  - 'Conserved_Mammal_phastCons46wayL2'
  - 'Conserved_Mammal_phastCons46way.flanking.500L2'
  - 'Conserved_Primate_phastCons46wayL2'
  - 'Conserved_Primate_phastCons46way.flanking.500L2'
  - 'BivFlnkL2'
  - 'BivFlnk.flanking.500L2'
  - 'Human_Promoter_VillarL2'
  - 'Human_Promoter_Villar.flanking.500L2'
  - 'Human_Enhancer_VillarL2'
  - 'Human_Enhancer_Villar.flanking.500L2'
  - 'Ancient_Sequence_Age_Human_PromoterL2'
  - 'Ancient_Sequence_Age_Human_Promoter.flanking.500L2'
  - 'Ancient_Sequence_Age_Human_EnhancerL2'
  - 'Ancient_Sequence_Age_Human_Enhancer.flanking.500L2'
  - 'Human_Enhancer_Villar_Species_Enhancer_CountL2'
  - 'Human_Promoter_Villar_ExACL2'
  - 'Human_Promoter_Villar_ExAC.flanking.500L2'
#+END_SRC

** Model parameters

There are a lot of annotations we've been working with.
Under each heading are the annotations associated with that model.  ~clean~ and ~full~ refer 
to LD score regression baselines.

#+BEGIN_SRC yaml :tangle ../workflow/annots.yaml
  ---
  clean:
    - base
    - Coding_UCSC
    - Conserved_LindbladToh
    - Intron_UCSC
    - PromoterFlanking_Hoffman
    - Promoter_UCSC
    - Transcr_Hoffman
    - TSS_Hoffman
    - UTR_3_UCSC
    - UTR_5_UCSC
    - GERP.NS
    - GERP.RSsup4
    - MAFbin1
    - MAFbin2
    - MAFbin3
    - MAFbin4
    - MAFbin5
    - MAFbin6
    - MAFbin7
    - MAFbin8
    - MAFbin9
    - MAFbin10
    - MAF_Adj_Predicted_Allele_Age
    - MAF_Adj_LLD_AFR
    - Recomb_Rate_10kb
    - Nucleotide_Diversity_10kb
    - Backgrd_Selection_Stat
    - CpG_Content_50kb
    - MAF_Adj_ASMC
    - synonymous
    - non_synonymous
    - Conserved_Vertebrate_phastCons46way
    - Conserved_Mammal_phastCons46way
    - Conserved_Primate_phastCons46way
    - BivFlnk
  full: 
    - base
    - Coding_UCSC
    - Conserved_LindbladToh
    - CTCF_Hoffman
    - DGF_ENCODE
    - DHS_peaks_Trynka
    - DHS_Trynka
    - Enhancer_Andersson
    - Enhancer_Hoffman
    - FetalDHS_Trynka
    - H3K27ac_Hnisz
    - H3K27ac_PGC2
    - H3K4me1_peaks_Trynka
    - H3K4me1_Trynka
    - H3K4me3_peaks_Trynka
    - H3K4me3_Trynka
    - H3K9ac_peaks_Trynka
    - H3K9ac_Trynka
    - Intron_UCSC
    - PromoterFlanking_Hoffman
    - Promoter_UCSC
    - Repressed_Hoffman
    - SuperEnhancer_Hnisz
    - TFBS_ENCODE
    - Transcr_Hoffman
    - TSS_Hoffman
    - UTR_3_UCSC
    - UTR_5_UCSC
    - WeakEnhancer_Hoffman
    - GERP.NS
    - GERP.RSsup4
    - MAFbin1
    - MAFbin2
    - MAFbin3
    - MAFbin4
    - MAFbin5
    - MAFbin6
    - MAFbin7
    - MAFbin8
    - MAFbin9
    - MAFbin10
    - MAF_Adj_Predicted_Allele_Age
    - MAF_Adj_LLD_AFR
    - Recomb_Rate_10kb
    - Nucleotide_Diversity_10kb
    - Backgrd_Selection_Stat
    - CpG_Content_50kb
    - MAF_Adj_ASMC
    - GTEx_eQTL_MaxCPP
    - BLUEPRINT_H3K27acQTL_MaxCPP
    - BLUEPRINT_H3K4me1QTL_MaxCPP
    - BLUEPRINT_DNA_methylation_MaxCPP
    - synonymous
    - non_synonymous
    - Conserved_Vertebrate_phastCons46way
    - Conserved_Mammal_phastCons46way
    - Conserved_Primate_phastCons46way
    - BivFlnk
    - Human_Promoter_Villar
    - Human_Enhancer_Villar
    - Ancient_Sequence_Age_Human_Promoter
    - Ancient_Sequence_Age_Human_Enhancer
    - Human_Enhancer_Villar_Species_Enhancer_Count
    - Human_Promoter_Villar_ExAC
  ptb_torus_model:
    allhic:
      - chip-seq-dec_diff-H3K27ac
      - chip-seq-reproducible-ctr-H3K4me1
      - hicd-seq-both-dec-HIC
    treatedhic:
      - chip-seq-reproducible-dec-H3K27ac
      - chip-seq-reproducible-dec-H3K4me1
      - hicd-seq-both-dec-HIC
    reproduciblemerged:
      - chip-seq-reproducible-ctr-H3K4me3
      - chip-seq-reproducible-dec-H3K4me3
      - chip-seq-reproducible-dec-H3K27ac
      - chip-seq-reproducible-ctr-H3K27ac
      - chip-seq-reproducible-dec-H3K4me1
      - chip-seq-reproducible-ctr-H3K4me1
      - atac-seq-reproducible-dec-ATAC
      - atac-seq-reproducible-ctr-ATAC
      - atac-seq-dec_diff-ATAC
      - chip-seq-dec_diff-H3K4me3
      - chip-seq-dec_diff-H3K27ac
      - chip-seq-dec_diff-H3K4me1
      - hicd-seq-both-dec-HIC
    utme3treatedhic:
      - chip-seq-reproducible-ctr-H3K4me3
      - chip-seq-reproducible-dec-H3K27ac
      - chip-seq-reproducible-dec-H3K4me1
      - hicd-seq-both-dec-HIC
    untreatedhic:
      - chip-seq-reproducible-ctr-H3K27ac
      - chip-seq-reproducible-ctr-H3K4me1
      - hicd-seq-both-dec-HIC
    targethic:
      - chip-seq-dec_diff-H3K27ac
      - chip-seq-reproducible-ctr-H3K4me1
      - hicd-seq-target-dec-HIC
    baithic:
      - chip-seq-dec_diff-H3K27ac
      - chip-seq-reproducible-ctr-H3K4me1
      - hicd-seq-bait-dec-HIC
  ptb_ldsc_model:
    nopooled: 
      - chip-seq-reproducible-ctr-H3K4me3
      - chip-seq-reproducible-dec-H3K27ac
      - chip-seq-reproducible-dec-H3K4me3
      - chip-seq-reproducible-dec-H3K4me1
      - chip-seq-reproducible-ctr-H3K4me1
      - atac-seq-reproducible-dec-ATAC
      - chip-seq-reproducible-ctr-H3K27ac
      - atac-seq-reproducible-ctr-ATAC
      - chip-seq-dec_up-H3K4me1
      - chip-seq-dec_up-H3K4me3
      - atac-seq-dec_down-ATAC
      - chip-seq-dec_up-H3K27ac
      - chip-seq-dec_down-H3K4me3
      - atac-seq-dec_up-ATAC
      - chip-seq-dec_down-H3K27ac
      - chip-seq-dec_down-H3K4me1
    full: 
      - chip-seq-pooled-DSC1-dec-H3K27ac
      - atac-seq-pooled-DSC2-dec-ATAC
      - chip-seq-pooled-DSC1-ctr-H3K4me3
      - atac-seq-pooled-DSC3-ctr-ATAC
      - chip-seq-pooled-DSC3-ctr-H3K4me1
      - chip-seq-pooled-DSC1-ctr-H3K4me1
      - atac-seq-pooled-DSC1-ctr-ATAC
      - chip-seq-pooled-DSC3-dec-H3K4me3
      - chip-seq-pooled-DSC2-ctr-H3K4me1
      - chip-seq-pooled-DSC1-dec-H3K4me1
      - chip-seq-pooled-DSC2-ctr-H3K27ac
      - chip-seq-pooled-DSC2-dec-H3K4me1
      - chip-seq-pooled-DSC1-dec-H3K4me3
      - chip-seq-pooled-DSC2-dec-H3K27ac
      - chip-seq-pooled-DSC3-dec-H3K27ac
      - chip-seq-pooled-DSC3-dec-H3K4me1
      - chip-seq-pooled-DSC2-dec-H3K4me3
      - chip-seq-pooled-DSC2-ctr-H3K4me3
      - atac-seq-pooled-DSC1-dec-ATAC
      - chip-seq-pooled-DSC1-ctr-H3K27ac
      - atac-seq-pooled-DSC2-ctr-ATAC
      - atac-seq-pooled-DSC3-dec-ATAC
      - chip-seq-pooled-DSC3-ctr-H3K27ac
      - chip-seq-reproducible-ctr-H3K4me3
      - chip-seq-reproducible-dec-H3K27ac
      - chip-seq-reproducible-dec-H3K4me3
      - chip-seq-reproducible-dec-H3K4me1
      - chip-seq-reproducible-ctr-H3K4me1
      - atac-seq-reproducible-dec-ATAC
      - chip-seq-reproducible-ctr-H3K27ac
      - atac-seq-reproducible-ctr-ATAC
      - chip-seq-dec_up-H3K4me1
      - chip-seq-dec_up-H3K4me3
      - chip-seq-pooled-DSC3-ctr-H3K4me3
      - atac-seq-dec_down-ATAC
      - chip-seq-dec_up-H3K27ac
      - chip-seq-dec_down-H3K4me3
      - atac-seq-dec_up-ATAC
      - chip-seq-dec_down-H3K27ac
      - chip-seq-dec_down-H3K4me1
    reproducible:
      - chip-seq-reproducible-ctr-H3K4me3
      - chip-seq-reproducible-dec-H3K4me3
      - chip-seq-reproducible-dec-H3K27ac
      - chip-seq-reproducible-ctr-H3K27ac
      - chip-seq-reproducible-dec-H3K4me1
      - chip-seq-reproducible-ctr-H3K4me1
      - atac-seq-reproducible-dec-ATAC
      - atac-seq-reproducible-ctr-ATAC
    reproducibledec:
      - chip-seq-reproducible-dec-H3K4me3
      - chip-seq-reproducible-dec-H3K27ac
      - chip-seq-reproducible-dec-H3K4me1
      - atac-seq-reproducible-dec-ATAC
    reproduciblectr:
      - chip-seq-reproducible-ctr-H3K4me3
      - chip-seq-reproducible-ctr-H3K27ac
      - chip-seq-reproducible-ctr-H3K4me1
      - atac-seq-reproducible-ctr-ATAC
    reproducible_up_down:
      - chip-seq-reproducible-ctr-H3K4me3
      - chip-seq-reproducible-dec-H3K4me3
      - chip-seq-reproducible-dec-H3K27ac
      - chip-seq-reproducible-ctr-H3K27ac
      - chip-seq-reproducible-dec-H3K4me1
      - chip-seq-reproducible-ctr-H3K4me1
      - atac-seq-reproducible-dec-ATAC
      - atac-seq-reproducible-ctr-ATAC
      - chip-seq-dec_up-H3K4me1
      - chip-seq-dec_up-H3K4me3
      - atac-seq-dec_down-ATAC
      - chip-seq-dec_up-H3K27ac
      - chip-seq-dec_down-H3K4me3
      - atac-seq-dec_up-ATAC
      - chip-seq-dec_down-H3K27ac
      - chip-seq-dec_down-H3K4me1
      - hicd-seq-bait-dec-HIC
      - hicd-seq-target-dec-HIC
    reproduciblemerged:
      - chip-seq-reproducible-ctr-H3K4me3
      - chip-seq-reproducible-dec-H3K4me3
      - chip-seq-reproducible-dec-H3K27ac
      - chip-seq-reproducible-ctr-H3K27ac
      - chip-seq-reproducible-dec-H3K4me1
      - chip-seq-reproducible-ctr-H3K4me1
      - atac-seq-reproducible-dec-ATAC
      - atac-seq-reproducible-ctr-ATAC
      - atac-seq-dec_diff-ATAC
      - chip-seq-dec_diff-H3K4me3
      - chip-seq-dec_diff-H3K27ac
      - chip-seq-dec_diff-H3K4me1
      - hicd-seq-both-dec-HIC
    reproduciblenodiff:
      - chip-seq-reproducible-ctr-H3K4me3
      - chip-seq-reproducible-dec-H3K4me3
      - chip-seq-reproducible-dec-H3K27ac
      - chip-seq-reproducible-ctr-H3K27ac
      - chip-seq-reproducible-dec-H3K4me1
      - chip-seq-reproducible-ctr-H3K4me1
      - atac-seq-reproducible-dec-ATAC
      - atac-seq-reproducible-ctr-ATAC
      - hicd-seq-both-dec-HIC
    reproduciblenodiffcsmc:
      - chip-seq-reproducible-ctr-H3K4me3
      - chip-seq-reproducible-dec-H3K4me3
      - chip-seq-reproducible-dec-H3K27ac
      - chip-seq-reproducible-ctr-H3K27ac
      - chip-seq-reproducible-dec-H3K4me1
      - chip-seq-reproducible-ctr-H3K4me1
      - atac-seq-reproducible-dec-ATAC
      - atac-seq-reproducible-ctr-ATAC
      - hicd-seq-both-dec-HIC
      - peaks-cervical_smooth_muscle_cells
    reproduciblenodiffaorta:
      - chip-seq-reproducible-ctr-H3K4me3
      - chip-seq-reproducible-dec-H3K4me3
      - chip-seq-reproducible-dec-H3K27ac
      - chip-seq-reproducible-ctr-H3K27ac
      - chip-seq-reproducible-dec-H3K4me1
      - chip-seq-reproducible-ctr-H3K4me1
      - atac-seq-reproducible-dec-ATAC
      - atac-seq-reproducible-ctr-ATAC
      - hicd-seq-both-dec-HIC
      - chip-seq-reproducible-aorta-H3K4me1
      - chip-seq-reproducible-aorta-H3K4me3
      - chip-seq-reproducible-aorta-H3K27ac
    reproduciblenodifffinte:
      - chip-seq-reproducible-ctr-H3K4me3
      - chip-seq-reproducible-dec-H3K4me3
      - chip-seq-reproducible-dec-H3K27ac
      - chip-seq-reproducible-ctr-H3K27ac
      - chip-seq-reproducible-dec-H3K4me1
      - chip-seq-reproducible-ctr-H3K4me1
      - atac-seq-reproducible-dec-ATAC
      - atac-seq-reproducible-ctr-ATAC
      - hicd-seq-both-dec-HIC
      - chip-seq-reproducible-finte-H3K4me1
      - chip-seq-reproducible-finte-H3K4me3
      - chip-seq-reproducible-finte-H3K27ac
    reproduciblenodiffliver:
      - chip-seq-reproducible-ctr-H3K4me3
      - chip-seq-reproducible-dec-H3K4me3
      - chip-seq-reproducible-dec-H3K27ac
      - chip-seq-reproducible-ctr-H3K27ac
      - chip-seq-reproducible-dec-H3K4me1
      - chip-seq-reproducible-ctr-H3K4me1
      - atac-seq-reproducible-dec-ATAC
      - atac-seq-reproducible-ctr-ATAC
      - hicd-seq-both-dec-HIC
      - chip-seq-reproducible-liver-H3K4me1
      - chip-seq-reproducible-liver-H3K4me3
      - chip-seq-reproducible-liver-H3K27ac
    reproduciblemergedcsmc:
      - chip-seq-reproducible-ctr-H3K4me3
      - chip-seq-reproducible-dec-H3K4me3
      - chip-seq-reproducible-dec-H3K27ac
      - chip-seq-reproducible-ctr-H3K27ac
      - chip-seq-reproducible-dec-H3K4me1
      - chip-seq-reproducible-ctr-H3K4me1
      - atac-seq-reproducible-dec-ATAC
      - atac-seq-reproducible-ctr-ATAC
      - atac-seq-dec_diff-ATAC
      - chip-seq-dec_diff-H3K4me3
      - chip-seq-dec_diff-H3K27ac
      - chip-seq-dec_diff-H3K4me1
      - hicd-seq-both-dec-HIC
      - peaks-cervical_smooth_muscle_cells



#+END_SRC

** Snakemake Analysis Pipeline

** Master rule


#+BEGIN_SRC snakemake :tangle ../workflow/snakefile
  import os
  import yaml
  from yaml import Loader
  import json
  import re


  with open('../workflow/regs.txt') as reg_file:
    all_regions = [int(x)-1 for x in reg_file]

  with open('../workflow/ldetect_ch.json') as json_file:
    ldetect_data = json.load(json_file)


  regions=[614,15,356,373,353,973,512,181,363,362]
  all_regions=all_regions

  def host_loader(loader,node):
      fields = loader.construct_mapping(node,deep=True)
      options=fields['options']
      # print([options[name] for name in options.keys()])
      ret_opt = [name for name in options.keys() if os.path.exists(options[name])]
      # print(ret_opt)
      return ret_opt[0]


  def dep_loader(loader,node):
      options = loader.construct_mapping(node,deep=True)
      host = options['host']
      pref = options['pref']
      # print(pref)
      host =options['host']
      path = options['path']
      full_path = pref+path[host] if pref is not None else path[host]
      return full_path

  yaml.Loader.add_constructor('!Host', host_loader)
  yaml.Loader.add_constructor('!Dep', dep_loader)


  with open("../workflow/config_base.yaml") as stream:
      config=yaml.load(stream,Loader=Loader)

  config_d = config['paths']
  config_e = config['envs']
  shell.prefix(config_e["cmd_prefix"])



  def anno_files(anno):
    return expand(config_d['BED'] +"{anno_name}.bed",anno_name=anno)

  with open("../workflow/annots.yaml", 'r') as stream:
      all_annot = yaml.safe_load(stream)
        #(all_annot)

  wildcard_constraints:
        chrom="\d+",
        gwas="[fgdptb]+",
        full_anno_name="[a-z]+",
        new_base="[a-z]+",
        region_id="\d+"

  localrules: all,get_hm3_snplist,get_plinkfiles,get_frq,get_weights,get_narrowpeak_aorta,get_narrowpeak_finte,get_narrowpeak_liver,prep_covars

  #include: "h5_gwas_snakefile"
  include: "dl_snakefile"
  include: "eqtl_snakefile"
  #include: "gwas_snakefile"
  include: "plot_snakefile"
  include: "ldsc_snakefile" 


  rule all:
      input:
          expand(config_d['OBERF']+'output/{region_id}_{PCN}.txt.gz',region_id=all_regions,PCN=range(5))


#+END_SRC

** Downloading files

The first step is to download some LD score regression stuff from the web. In particular we want a gzipped tarball of the hapmap 3 SNPs.

#+BEGIN_SRC snakemake :mkdirp :tangle ../workflow/dl_snakefile



  # rule get_hic:
  #     output:

  #     shell:
  #         "curl --digest --user {params.username}:{params.password} https://mnlab.uchicago.edu/mod/download/hi-c/DT1_dTL4_D_48h.ibed.bz2 --output {output}


  rule get_gest_dur_gwas:
      output:
          temp(config_d['GWAS']+"fetal_gest_duration/Fetal_gest_duration_NComms2019.txt.gz")
      shell:
          "wget http://mccarthy.well.ox.ac.uk/publications/2019/EggGestationalDuration_NatureCommunications/Fetal_gest_duration_NComms2019.txt.gz -O {output}"

  rule mv_fgd:
      input:
          config_d['GWAS']+"fetal_gest_duration/Fetal_gest_duration_NComms2019.txt.gz"
      output:
          temp(config_d['GWAS']+"input/fgd.txt")
      shell:
          "zcat {input} > {output}"


  rule mv_ptb:
      input:
          config_d['GWAS']+"meta.stat"
      output:
          temp(config_d['GWAS']+"input/ptb.txt")
      shell:
          "cp {input} {output}"        

  rule get_hm3_snplist:
      output:
          temp(config_d['DL'] +"hapmap3_snps.tgz")
      shell:
          "wget https://data.broadinstitute.org/alkesgroup/LDSCORE/hapmap3_snps.tgz -O {output}"
#+END_SRC

Next we'll unzip the files and put them somewhere on disk.

#+BEGIN_SRC snakemake :mkdirp :tangle ../workflow/dl_snakefile

  rule get_narrowpeak_aorta:
      output:
          config_d["BED"]+"chip-seq-reproducible-aorta-{mark}.bed.bz2"
      params:
          mark="{mark}"
      shell:
          "curl https://egg2.wustl.edu/roadmap/data/byFileType/peaks/consolidated/narrowPeak/E065-{params.mark}.narrowPeak.gz | gunzip -c | bzip2 -c > {output}"



  rule get_narrowpeak_finte:
      output:
          config_d["BED"]+"chip-seq-reproducible-finte-{mark}.bed.bz2"
      params:
          mark="{mark}"
      shell:
          "curl https://egg2.wustl.edu/roadmap/data/byFileType/peaks/consolidated/narrowPeak/E085-{params.mark}.narrowPeak.gz | gunzip -c | bzip2 -c > {output}"


  rule get_narrowpeak_liver:
      output:
          config_d["BED"]+"chip-seq-reproducible-liver-{mark}.bed.bz2"
      params:
          mark="{mark}"
      shell:
          "curl https://egg2.wustl.edu/roadmap/data/byFileType/peaks/consolidated/narrowPeak/E066-{params.mark}.narrowPeak.gz | gunzip -c | bzip2 -c > {output}"


  # rule get_broadpeak_aorta:
  #     output:
  #         config_d["BED"]+"chip-seq-reproducible-aorta-{mark}.bed.bz2"
  #     params:
  #         mark="{mark}"
  #     shell:
  #         "curl https://egg2.wustl.edu/roadmap/data/byFileType/peaks/consolidated/broadPeak/E065-{params.mark}.broadPeak.gz | gunzip -c | bzip2 -c > {output}"

  rule gunzip_hm3:
      input:
          rules.get_hm3_snplist.output
      params:
          dld=config_d['1KG']
      output:
          expand(config_d['1KG']+"hapmap3_snps/"+"hm.{chrom}.snp",chrom=range(1,23))
      shell:
          "tar -C {params.dld} -xvzf {input}"


#+END_SRC

** Preprocessing

*** rsid matching 

The rsids don't come with coordinates, and we don't have coordinates for our GWAS data, so we'll use the ~SNPlocs.Hsapiens.dbSNP144.GRCh37~ package 
to get the coordinates corresponding to these rsids.  Also note that we won't be able to get all of them, as some rsids have been merged by NCBI.

#+BEGIN_SRC R :mkdirp :tangle ../scripts/rsid2loc.R

library(dplyr)
library(purrr)
library(readr)


library(ldmap)


  input_f <- snakemake@input[["input"]]
  output_f <- snakemake@output[["output"]]
  input_ids <- EigenH5::fast_str2int(scan(input_f, what = character()), prefix = "rs")
  input_ids <- input_ids[!is.na(input_ids)]
  BSgenome::snpsById(SNPlocs.Hsapiens.dbSNP144.GRCh37::SNPlocs.Hsapiens.dbSNP144.GRCh37,
                     ids = input_ids,
                     ifnotfound = "warn") %>% as_tibble() %>% 
      dplyr::rename(chrom = seqnames, rsid = RefSNP_id) %>%
      dplyr::mutate(chrom = as.integer(chrom),
                    rsid = rsid) %>%
      select(-strand) %>%
      readr::write_tsv(output_f)

#+END_SRC

#+RESULTS:

*** Annotation Merging

**** down+up->diff
We're going to merge the ~dec_down~ and ~dec_up~ annotations to create a ~dec_diff~ annotation

#+BEGIN_SRC R :mkdirp :tangle ../scripts/merge_diff.R
  library(dplyr)
library(purrr)
library(readr)


  library(ldmap)
  library(EigenH5)

  input_down <- snakemake@input[["input_down"]]
  input_up <- snakemake@input[["input_up"]]

  outputf <- snakemake@output[["bedf"]]

  dcols <- cols(
    chrom = col_factor(paste0("chr", c(as.character(1:22), "X"))),
    start = col_integer(),
    end = col_integer())

  diff_df <- vroom::vroom(c(input_up, input_down),
                          delim = "\t",
                          col_names = c("chrom", "start", "end"),
                          col_types = dcols)
  new_ldmap_region(diff_df$chrom,
                  diff_df$start,
                  diff_df$end) %>%
    split_ldmap_region_overlap() %>%
    ldmap_region_2_data_frame() %>%
    vroom::vroom_write(outputf, delim = "\t", col_names = FALSE)
#+END_SRC




#+BEGIN_SRC snakemake :mkdirp :tangle ../workflow/dl_snakefile

  rule merge_down_up:
      input:
          input_down=config_d['BED']+"{chip_atac}-seq-dec_down-{mark}.bed",
          input_up=config_d['BED']+"{chip_atac}-seq-dec_up-{mark}.bed"
      output:
          bedf=config_d['BED']+"{chip_atac}-seq-dec_diff-{mark}.bed"
      conda:
          config_e['r']
      script:
          "../scripts/merge_diff.R"

#+END_SRC

**** HiC combinations
I'll create three annotations out of the HiC data.  One will contain baits only, one targets only and one target|bait

#+BEGIN_SRC R :mkdirp :tangle ../scripts/merge_hic.R
  library(dplyr)
  library(forcats)
  library(purrr)
  library(readr)


  library(ldmap)
  library(EigenH5)
  cold <- cols(
    bait_chr = col_factor(paste0("chr", c(as.character(1:22), c("X","Y")))),
    bait_start = col_double(),
    bait_end = col_double(),
    bait_name = col_character(),
    otherEnd_chr = col_factor(paste0("chr", c(as.character(1:22), c("X","Y")))),
    otherEnd_start = col_double(),
    otherEnd_end = col_double(),
    otherEnd_name = col_character(),
    N_reads = col_double(),
    score = col_double()
  )
  input_hic <- read_tsv(snakemake@input[["inputf"]],col_names=names(cold$cols),col_types=cold,skip=1L) %>%
    filter(bait_chr!="chrY", otherEnd_chr!="chrY")  %>%
    mutate(bait_chr = fct_drop(bait_chr), otherEnd_chr = fct_drop(otherEnd_chr))

  baitf <- snakemake@output[["bait"]]
  targetf <- snakemake@output[["target"]]
  bothf <- snakemake@output[["both"]]

  bait_ld <- new_ldmap_region(input_hic$bait_chr,
                             input_hic$bait_start,
                             input_hic$bait_end)

  target_ld <- new_ldmap_region(input_hic$otherEnd_chr,
                               input_hic$otherEnd_start,
                               input_hic$otherEnd_end)

  both_ld <- merge_ldmap_regions(bait_ld,target_ld)

  ldmap_region_2_data_frame(bait_ld) %>%
    write_tsv(baitf, col_names = FALSE)
  ldmap_region_2_data_frame(target_ld) %>%
    write_tsv(targetf, col_names = FALSE)
  ldmap_region_2_data_frame(both_ld) %>%
    write_tsv(bothf, col_names = FALSE)


#+END_SRC

#+RESULTS:



#+BEGIN_SRC snakemake :mkdirp :tangle ../workflow/dl_snakefile

  rule merge_split_hic:
      input:
          inputf=config_d['BED']+"DT1_dTL4_D_48h.ibed.bz2",
      output:
          bait=config_d['BED']+"hicd-seq-bait-dec-HIC.bed",
          target=config_d['BED']+"hicd-seq-target-dec-HIC.bed",
          both=config_d['BED']+"hicd-seq-both-dec-HIC.bed"
      conda:
          config_e['r']
      script:
          "../scripts/merge_hic.R"

#+END_SRC


** Munging the GWAS data

Unfortunately I don't have a remote source for the gwas summary statistics I can point you to, so we'll just pretend like you know
how to get to `meta.stat` the PTB gwas file.  First thing is to convert it to HDF5 for easier read/write of subsets

*** Munging strategy

We're going to create a ~cols~ object for each file. We'll ignore column names in every instance and use our own. 


#+BEGIN_SRC R :mkdirp :tangle ../scripts/ptbcols.R
  mc <- cols(
      rsid = col_character(),
      chrom = col_factor(c(as.character(1:22), "X")),
      pos = col_double(),
      A1 = col_character(),
      A2 = col_character(),
      N = col_double(),
      freq = col_double(),
      beta = col_double(),
      se = col_double(),
      pval = col_double(),
      Q = col_double(),
      het = col_double(),
      N.local = col_double(),
      freq.local = col_double(),
      beta.local = col_double(),
      se.local = col_double(),
      pval.local = col_double(),
      N.23andMe = col_double(),
      freq.23andMe = col_double(),
      beta.23andMe = col_double(),
      se.23andMe = col_double(),
      pval.23andMe = col_double()
  )
data_delim <- "\t"

#+END_SRC

#+BEGIN_SRC R :mkdirp :tangle ../scripts/fgdcols.R

  mc <- cols(
    chrom = col_factor(c(as.character(1:22), "X")),
    pos = col_double(), #Pos
    rsid = col_character(), #Rsid
    A1 = col_character(), #Effect_allele
    A2 = col_character(), #Non_effect_allele
    beta = col_double(), #Effect
    se = col_double(), #StdErr
    pval = col_double(), #P
    HetPVal = col_double(),
    N = col_double(),
    SNP = col_character()
  )
  data_delim <- " "

#+END_SRC


#+BEGIN_SRC R :mkdirp :tangle ../scripts/gwas2h5.R

  library(dplyr)
  library(purrr)
  library(readr)
  library(EigenH5)
  library(readr)
  library(ldmap)



  input_f <- snakemake@input[["inputf"]]
  output_f <- snakemake@output[["outputf"]]
  paramf <- snakemake@input[["paramf"]]
  stopifnot(!is.null(paramf))
  source(paramf)


  callback_fun <- function(df, filename, datapath, ...){
    write_df_h5(
      df = dplyr::slice(
                    dplyr::mutate(df,
                                  ref = fast_str2ascii(A2),
                                  alt = fast_str2ascii(A1),
                                  snp_struct =
                                    new_ldmap_snp(chrom, pos, ref, alt),
                                  rsid = fast_str2int(rsid, prefix = "rs"),
                                  ),
                    rank.ldmap_snp(snp_struct)),
      filename = filename, datapath = datapath, ... = ...)
  }

  stopifnot(!is.null(input_f),
            !is.null(output_f),
            file.exists(input_f),
            !file.exists(output_f))

  delim2h5(input_f,
           output_file = output_f,
           h5_args = list(datapath = "snp"),
           delim = data_delim,
           col_names = names(mc$cols),
           skip = 1L,
           callback_fun = callback_fun,
           col_types = mc,
           progress = FALSE,
           chunk_size = 150000)

  chrom_vec <- read_vector_h5v(output_f, "snp/chrom", i = integer())
  chrom_df <- rle2offset(as.integer(chrom_vec)) %>%
    dplyr::rename(chrom = value) %>% 
    mutate(offset=as.integer(offset),datasize=as.integer(datasize))
  write_df_h5(chrom_df,output_f,"chrom_offset")
#+END_SRC


Next is to write some code to pull out the indices with the matching rsids (using coordinates, not rsid)


#+BEGIN_SRC R :mkdirp :tangle ../scripts/index_gwas.R

  library(dplyr)
  library(purrr)
  library(readr)
  library(vroom)
  library(EigenH5)
  library(ldmap)

  input_f <- snakemake@input[["inputf"]]
  index_f <-  snakemake@input[["indexf"]]
  chrom <- snakemake@params[["chrom"]]
  stopifnot(!is.null(chrom))
  schrom <- as.integer(chrom)
  output_f <- snakemake@output[["outputf"]]


  ind_spec <- cols_only(
    CHR = col_integer(),
    BP = col_double(),
    SNP = col_character()
  )

  gwas_type <- if_else(
    is.null(snakemake@params[["gwas_t"]]),
    "",
    paste0(".", snakemake@params[["gwas_t"]])
  )

  beta_col <- glue::glue("beta{gwas_type}")
  se_col <- glue::glue("se{gwas_type}")
  N_col <- glue::glue("N{gwas_type}")
  P_col <- glue::glue("pval{gwas_type}")

  sel_cols <- c("snp_struct",
                beta_col,
                "A1",
                "A2",
                se_col,
                N_col,
                P_col)

  sel_cols <- stringr::str_replace(
                         sel_cols,
                         "\\.$",
                         "")

  index_df <- vroom::vroom(
                       index_f,
                       delim = "\t",
                       col_types = ind_spec
                     )  %>% 
    rename(chrom = CHR, rsid = SNP, pos = BP)
  nr_index_df <- nrow(index_df)

  chrom_df <- read_df_h5(input_f, "chrom_offset")

  jdf <- pmap_dfr(chrom_df, function(chrom, datasize, offset) {
                                          #    subset_l <- seq(offset + 1, length.out = datasize)
    input_i <- EigenH5::read_df_h5(filename = input_f,
                                   datapath = "snp",
                                   subcols = sel_cols,
                                   offset=offset,
                                   datasize=datasize) %>%
      mutate(subset = (1:n()) + offset)

    inner_join(index_df,  bind_cols(input_i,ldmap::ldmap_snp_2_dataframe(input_i$snp_struct)))
  })

                                          #%>% mutate(snp_struct = as_ldmap_snp(snp_struct))  %>%
  stopifnot(all(jdf$chrom == schrom))
  stopifnot(nrow(jdf)>0)
  ## stopifnot(nrow(jdf) == nr_index_df)

  jdf  %>% rename(beta =  {{beta_col}},
                  se =  {{se_col}},
                  N =  {{N_col}}) %>%
    dplyr::distinct(rsid, .keep_all = TRUE) %>% 
    dplyr::transmute(SNP = rsid, N = N, Z = beta / se, A1 = A1, A2 = A2,P=pval) %>%
    vroom::vroom_write(output_f,delim = "\t")
#+END_SRC

#+BEGIN_SRC R :mkdirp :tangle ../scripts/gen_ldsc_sumstats.R
library(vroom)
library(magrittr)

 input_f <- snakemake@input[["inputf"]]
 output <- snakemake@output[["outputf"]]

 vroom::vroom(input_f,delim="\t") %>% vroom_write(output,delim="\t")


#+END_SRC


#+BEGIN_SRC snakemake :mkdirp :tangle ../workflow/h5_gwas_snakefile

  rule ptb_gwas2h5:
      input:
          inputf=ancient(config_d['GWAS']+"input/{gwas}.txt"),
          paramf="../scripts/{gwas}cols.R"
      output:
          outputf=protected(config_d['GWAS'] +"{gwas}_gwas.h5")
      conda:
          config_e['r']
      script:
          "../scripts/gwas2h5.R"


#+END_SRC


** Running LDSC

#+BEGIN_SRC snakemake :mkdirp :tangle ../workflow/dl_snakefile

  rule get_cadd:
      output:
          temp(config_d["DL"]+"whole_genome_SNVs_inclAnno.tsv.gz")
      shell:
          "wget https://krishna.gs.washington.edu/download/CADD/v1.4/GRCh37/whole_genome_SNVs_inclAnno.tsv.gz -O {output}"

  rule get_spidex:
      output:
          temp(config_d["DL"]+"hg19_spidex.zip")
      shell:
          "wget http://www.openbioinformatics.org/annovar/download/IlvUMvrpPT/hg19_spidex.zip -O {output}"
  rule get_baseline_model:
      output:
          temp(config_d['DL']+"1000G_Phase3_baselineLD_v2.2_ldscores.tgz")
      shell:
          "wget https://data.broadinstitute.org/alkesgroup/LDSCORE/1000G_Phase3_baselineLD_v2.2_ldscores.tgz -O {output}"

  rule get_weights:
      output:
          temp(config_d["DL"]+"1000G_Phase3_weights_hm3_no_MHC.tgz")
      shell:
          "wget https://data.broadinstitute.org/alkesgroup/LDSCORE/1000G_Phase3_weights_hm3_no_MHC.tgz -O {output}"

  rule gunzip_weights:
      input:
          config_d["DL"]+"1000G_Phase3_weights_hm3_no_MHC.tgz"
      output:
          ldfiles = expand(config_d['WEIGHTS'] +"weights.hm3_noMHC.{chrom}.l2.ldscore.gz",chrom=range(1,23))
      params:
          W=config_d['1KG']
      shell:
          "tar -xvzf {input} -C {params.W}"        

  rule get_frq:
      output:
          temp(config_d['DL']+"1000G_Phase3_frq.tgz")
      shell:
          "wget https://data.broadinstitute.org/alkesgroup/LDSCORE/1000G_Phase3_frq.tgz -O {output}"


  rule get_plinkfiles:
      output:
          temp(config_d['DL'] +"1000G_Phase3_plinkfiles.tgz")
      shell:
          "wget https://data.broadinstitute.org/alkesgroup/LDSCORE/1000G_Phase3_plinkfiles.tgz -O {output}"

  rule gunzip_plinkfiles:
      input:
          config_d['DL'] +"1000G_Phase3_plinkfiles.tgz"
      output:
          fam_files = expand(config_d['1KG'] +"1000G_EUR_Phase3_plink/1000G.EUR.QC.{chrom}.fam",chrom=range(1,23)),
          bim_files = expand(config_d['1KG'] +"1000G_EUR_Phase3_plink/1000G.EUR.QC.{chrom}.bim",chrom=range(1,23)),
          bed_files = expand(config_d['1KG'] +"1000G_EUR_Phase3_plink/1000G.EUR.QC.{chrom}.bed",chrom=range(1,23))
      params:
          KG=config_d['1KG']
      shell:
          "tar -xvzf {input} -C {params.KG}"

  rule gunzip_frqf:
      input:
          config_d['DL'] +"1000G_Phase3_frq.tgz"
      output:
          fam_files = expand(config_d['FRQF'] +"1000G.EUR.QC.{chrom}.frq",chrom=range(1,23)),
      params:
          KG=config_d['1KG']
      shell:
          "tar -xvzf {input} -C {params.KG}"


  rule gunzip_baseline:
      input:
          config_d['DL'] +"1000G_Phase3_baselineLD_v2.2_ldscores.tgz"
      output:
          ldfiles = expand(config_d['L2'] +"baseline/baselineLD.{chrom}.l2.ldscore.gz",chrom=range(1,23)),
          annotf = expand(config_d['L2'] +"baseline/baselineLD.{chrom}.annot.gz",chrom=range(1,23)),
          m50 = expand(config_d['L2'] +"baseline/baselineLD.{chrom}.l2.M_5_50",chrom=range(1,23))
      params:
          L2=config_d['L2']
      shell:
          "tar -xvzf {input} -C {params.L2}/baseline"

  rule unzip_annot:
      input:
          config_d['BED'] + "{annot}.bed.bz2"
      output:
          temp(config_d['BED'] + "{annot}.bed")
      wildcard_constraints:
          annot="[^/]+"
      shell:
          "bzip2 -cd {input} > {output}"


#+END_SRC


#+BEGIN_SRC snakemake :mkdirp :tangle ../workflow/ldsc_snakefile


  rule indexgwas2h5:
      input:
          inputf=config_d['GWAS'] +"{gwas}_gwas.h5",
          indexf=config_d['L2'] +"baseline/baselineLD.{chrom}.l2.ldscore.gz"
      params:
          chrom="{chrom}"
      output:
          outputf=temp(config_d['GWAS'] +"hm3_index/{gwas}_gwas_hm_chr{chrom}.tsv")
      conda:
          config_e['r']
      script:
          "../scripts/index_gwas.R"



  rule make_annot:
      input:
          anno_bed=ancient(config_d['BED'] +"{annot}.bed"),
          bim=config_d['1KG'] + "1000G_EUR_Phase3_plink/1000G.EUR.QC.{chrom}.bim"
      output:
          annot = config_d['L2'] +"{annot}.{chrom}.annot.gz"
      params:
          anno_name='{annot}'
      conda:
          config_e['ldsc']
      shell:
          config_d['LDSC']+"make_annot.py --bed-file {input.anno_bed} --bimfile {input.bim} --annot-file {output.annot} --annot-name {params.anno_name}"


  rule prep_ldsc_sumstsat:
      input:
          inputf=expand(config_d['GWAS'] +"hm3_index/{{gwas}}_gwas_hm_chr{chrom}.tsv",chrom=range(1,23))
      params:
          gwas_t=""
      output:
          outputf=temp(config_d['GWAS'] +"ldsc_input_pre/{gwas}_gwas.sumstats.gz")
      conda:
          config_e['r']
      script:
          "../scripts/gen_ldsc_sumstats.R"


  rule check_ldsc_sumstat:
      input:
          config_d['GWAS'] +"ldsc_input_pre/{gwas}_gwas.sumstats.gz"
      output:
          outputf=config_d['GWAS'] +"ldsc_input/{gwas}_gwas.sumstats.gz"
      params:
          outputf=config_d['GWAS'] +"ldsc_input/{gwas}_gwas"
      conda:
          config_e['ldsc']
      log:
          logf=config_d['GWAS'] +"ldsc_input/{gwas}_gwas.log"
      shell:
          config_d['LDSC']+"munge_sumstats.py --sumstats {input} --out {params.outputf}"


  rule pull_rsid:
      input:
          config_d["L2"]+"baseline/baselineLD.{chrom}.l2.ldscore.gz"
      output:
          temp(config_d["L2"]+"snplist/{chrom}.snplist.txt")
      shell:
          "zcat {input} | cut -f 2 | tail -n +2 > {output}"


  def norr_ldsc(wildcards):
       chrom = wildcards.chrom
       annot = wildcards.annot
       anno_bed=config_d['L2'] +f"{annot}.{chrom}.annot.gz"
       snplistf=config_d["L2"]+f"snplist/{chrom}.snplist.txt"
       bim=config_d['1KG'] + f"1000G_EUR_Phase3_plink/1000G.EUR.QC.{chrom}.bim"
       bed=config_d['1KG'] + f"1000G_EUR_Phase3_plink/1000G.EUR.QC.{chrom}.bed"
       fam=config_d['1KG'] + f"1000G_EUR_Phase3_plink/1000G.EUR.QC.{chrom}.fam"
       l2=(config_d['L2']+f"{annot}.{chrom}.l2.M")
       l2M_50=(config_d['L2']+f"{annot}.{chrom}.l2.M_5_50")
       l2gz=(config_d['L2']+f"{annot}.{chrom}.l2.ldscore.gz")
       if all(os.path.exists(x) for x in [l2,l2M_50,l2gz]):
            return {}
       else:
            return {'anno_bed': anno_bed,
                    'snplistf': snplistf,
                    'bim': bim,
                    'bed': bed,
                    'fam': fam}


  rule cmp_ldscores:
      input:
          unpack(norr_ldsc)
      output:
          l2=(config_d['L2']+"{annot}.{chrom}.l2.M"),
          l2M_50=(config_d['L2']+"{annot}.{chrom}.l2.M_5_50"),
          l2gz=(config_d['L2']+"{annot}.{chrom}.l2.ldscore.gz")
      params:
          plink=config_d['1KG'] + "1000G_EUR_Phase3_plink/1000G.EUR.QC.{chrom}",
          odir=config_d['L2']+"{annot}.{chrom}",
          anno="{annot}"
      wildcard_constraints:
          annot="[^/]+"
      conda:
          config_e['ldsc']
      shell:
          config_d['LDSC']+"ldsc.py --l2 --bfile {params.plink} --print-snps {input.snplistf} --ld-wind-cm 1 --thin-annot --annot {input.anno_bed} --out {params.odir} && cp {output.l2gz} {output.l2gz}~ && zcat {output.l2gz}~ | sed '1s/L2/{params.anno}/' | gzip  > {output.l2gz} && rm {output.l2gz}~"

#+END_SRC

#+BEGIN_SRC R :mkdirp :tangle ../scripts/pull_ldscores_m50.R


library(vroom)
library(purrr)
library(fs)


anno_bed_if <- snakemake@input[["anno_bed"]]

l2m_if <- snakemake@input[["l2"]]
l2m50_if <- snakemake@input[["l2M_50"]]


l2m_of <- snakemake@output[["l2"]]
l2m50_of <- snakemake@output[["l2M_50"]]
pull_features <- snakemake@params[["features"]]

anno_cols <- scan(anno_bed_if,what = character(),nlines = 1)[-c(1:4)]

keep_cols <- anno_cols %in% pull_features


l2md <- scan(l2m_if,what=character(),nlines = 1)[keep_cols]
l2m50d <- scan(l2m50_if,what=character(),nlines = 1)[keep_cols]

write(paste0(l2md,collapse = "\t"), l2m_of)
write(paste0(l2m50d,collapse = "\t"),l2m50_of)

#+END_SRC


#+BEGIN_SRC R :mkdirp :tangle ../scripts/pull_ldscores.R


  library(vroom)
  library(purrr)
  library(fs)


  anno_bed_if <- snakemake@input[["anno_bed"]]
  l2gz_if <- snakemake@input[["l2gz"]]



  anno_bed_of <- snakemake@output[["anno_bed"]]
  l2gz_of <- snakemake@output[["l2gz"]]
  pull_features <- snakemake@params[["features"]]



  annot_prefix <- c("CHR","BP","SNP","CM")
  annot_cols <- c(annot_prefix, pull_features)
  names(annot_cols) <- annot_cols
  annot_cols <- map(annot_cols, ~col_guess())
  annot_cols <- vroom::cols_only(!!!annot_cols)





  l2_prefix <- c("CHR","SNP","BP")
  l2_cols <- c(l2_prefix, paste0(pull_features, "L2"))
  names(l2_cols) <- l2_cols
  l2_cols <- map(l2_cols, ~col_guess())
  l2_cols <- vroom::cols_only(!!!l2_cols)




  vroom::vroom_write(vroom::vroom(l2gz_if, delim = "\t",col_types = l2_cols),l2gz_of,delim = "\t")
  vroom::vroom_write(vroom::vroom(anno_bed_if,delim = "\t",col_types = annot_cols),anno_bed_of,delim = "\t")







#+END_SRC


#+BEGIN_SRC snakemake :mkdirp :tangle ../workflow/ldsc_snakefile

  rule cmp_baseline_ldscores:
      input:
          anno_bed=config_d['L2'] +"baseline/baselineLD.{chrom}.annot.gz",
          l2gz=config_d['L2'] +"baseline/baselineLD.{chrom}.l2.ldscore.gz",
      output:
          anno_bed=config_d['L2'] +"new_baseline/{new_base}.{chrom}.annot.gz",
          l2gz=config_d['L2'] +"new_baseline/{new_base}.{chrom}.l2.ldscore.gz",
      params:
          features=lambda wildcards: all_annot.get(wildcards.new_base),
          anno="{new_base}"
      script:
          "../scripts/pull_ldscores.R"




  rule cmp_baseline_ldscores2:
      input:
          anno_bed=config_d['L2'] +"baseline/baselineLD.{chrom}.annot.gz",
          l2=config_d['L2']+"baseline/baselineLD.{chrom}.l2.M",
          l2M_50=config_d['L2']+"baseline/baselineLD.{chrom}.l2.M_5_50"
      output:
          l2=config_d['L2']+"new_baseline/{new_base}.{chrom}.l2.M",
          l2M_50=config_d['L2']+"new_baseline/{new_base}.{chrom}.l2.M_5_50"
      params:
          features=lambda wildcards: all_annot.get(wildcards.new_base),
          anno="{new_base}"
      script:
          "../scripts/pull_ldscores_m50.R"






  def get_annot_files(wildcards):
          return {'anno_l2':expand(config_d['L2'] +"{anno_name}.{chrom}.l2.ldscore.gz",chrom=range(1,23),anno_name=all_annot['ptb_ldsc_model'][wildcards.anno_name]),
                  'annotf':expand(config_d['L2'] +"{anno_name}.{chrom}.annot.gz",chrom=range(1,23),anno_name=all_annot['ptb_ldsc_model'][wildcards.anno_name]),
                  'baseline_l2':expand(config_d['L2'] +"baseline/baselineLD.{chrom}.l2.ldscore.gz",chrom=range(1,23)),
                  'gwasf':config_d['GWAS'] +f"ldsc_input/{wildcards.gwas}_gwas.sumstats.gz",
                  'baselinef':  expand(config_d['WEIGHTS'] +"weights.hm3_noMHC.{chrom}.l2.ldscore.gz",chrom=range(1,23)),
                  'freqf':  expand(config_d['FRQF'] +"1000G.EUR.QC.{chrom}.frq",chrom=range(1,23)),
          }



  def get_annot_pairs(wildcards):
          return {'anno_l2':expand(config_d['L2'] +"{anno_name}.{chrom}.l2.ldscore.gz",chrom=range(1,23),anno_name=all_annot['ptb_ldsc_model'][wildcards.anno_name]),
                  'baseline_l2':expand(config_d['L2'] +"baseline/baselineLD.{chrom}.l2.ldscore.gz",chrom=range(1,23)),

                  'gwasfA':config_d['GWAS'] +f"ldsc_input/{wildcards.gwasA}_gwas.sumstats.gz",
                  'gwasfB':config_d['GWAS'] +f"ldsc_input/{wildcards.gwasB}_gwas.sumstats.gz",
                  'baselinef':  expand(config_d['WEIGHTS'] +"weights.hm3_noMHC.{chrom}.l2.ldscore.gz",chrom=range(1,23)),
                  'freqf':  expand(config_d['FRQF'] +"1000G.EUR.QC.{chrom}.frq",chrom=range(1,23)),
          }


  rule run_ldsc:
      input:
          unpack(get_annot_files)
      output:
          dataf="results/{gwas}/{anno_name}.results"
      log:
          tempf=temp("{gwas}_{anno_name}.log")
      params:
          annot=lambda wildcards: ','.join(expand(config_d['L2']+"{anno_name}.",anno_name=all_annot['ptb_ldsc_model'][wildcards.anno_name])),
          baseline=config_d['L2']+"baseline/baselineLD.",
          weights=config_d['WEIGHTS']+"weights.hm3_noMHC.",
          frq=config_d['FRQF'] +"1000G.EUR.QC.",
          odir="results/{gwas}/{anno_name}"
      conda:
          config_e['ldsc']
      shell:
          config_d['LDSC']+"ldsc.py --h2 {input.gwasf} --ref-ld-chr {params.annot},{params.baseline} --w-ld-chr {params.weights} --thin-annot --overlap-annot --frqfile-chr {params.frq} --out {params.odir} "




  rule run_ldsc_cor:
      input:
          unpack(get_annot_pairs)
      output:
          dataf="{gwasA},{gwasB}/{anno_name}.log"
      params:
          annot=lambda wildcards: ','.join(expand(config_d['L2']+"{anno_name}.",anno_name=all_annot['ptb_ldsc_model'][wildcards.anno_name])),
          baseline=config_d['L2']+"baseline/baselineLD.",
          weights=config_d['WEIGHTS']+"weights.hm3_noMHC.",
          frq=config_d['FRQF'] +"1000G.EUR.QC.",
          odir="{gwasA},{gwasB}/{anno_name}"
      conda:
          config_e['ldsc']
      shell:
          config_d['LDSC']+"ldsc.py --rg {input.gwasfA},{input.gwasfB} --ref-ld-chr {params.annot},{params.baseline} --w-ld-chr {params.weights} --thin-annot --overlap-annot --frqfile-chr {params.frq} --out {params.odir} "






  def get_new_annot_files(wildcards):

          return {'anno_l2':expand(config_d['L2'] +"{anno_name}.{chrom}.l2.ldscore.gz",chrom=range(1,23),anno_name=all_annot['ptb_ldsc_model'][wildcards.anno_name]),
                  'baseline_l2':expand(config_d['L2'] +"new_baseline/{new_base}.{chrom}.l2.ldscore.gz",chrom=range(1,23),new_base = wildcards.new_base),
                  'baseline_l2m':expand(config_d['L2'] +"new_baseline/{new_base}.{chrom}.l2.M",chrom=range(1,23),new_base = wildcards.new_base),
                  'baseline_l2m50':expand(config_d['L2'] +"new_baseline/{new_base}.{chrom}.l2.M_5_50",chrom=range(1,23),new_base = wildcards.new_base),
                  'gwasf':config_d['GWAS'] +f"ldsc_input/{wildcards.gwas}_gwas.sumstats.gz",
                  'baselinef':  expand(config_d['WEIGHTS'] +"weights.hm3_noMHC.{chrom}.l2.ldscore.gz",chrom=range(1,23)),
                  'freqf':  expand(config_d['FRQF'] +"1000G.EUR.QC.{chrom}.frq",chrom=range(1,23)),
          }




  rule run_new_ldsc:
        input:
            unpack(get_new_annot_files)
        output:
              dataf="results/{gwas}/{new_base}_{anno_name}.results"
        log:
            tempf=temp("{gwas}/{new_base}_{anno_name}.log")
        params:
            annot=lambda wildcards: ','.join(expand(config_d['L2']+"{anno_name}.",anno_name=all_annot['ptb_ldsc_model'][wildcards.anno_name])),
            baseline=config_d["L2"]+"new_baseline/{new_base}.",
            weights=config_d['WEIGHTS']+"weights.hm3_noMHC.",
            frq=config_d['FRQF'] +"1000G.EUR.QC.",
            odir="results/{gwas}/{new_base}_{anno_name}"
        conda:
            config_e['ldsc']
        shell:
            config_d['LDSC']+"ldsc.py --h2 {input.gwasf} --ref-ld-chr {params.annot},{params.baseline} --w-ld-chr {params.weights} --thin-annot --overlap-annot --frqfile-chr {params.frq} --out {params.odir}"




#+END_SRC





** Running Torus

The input that torus accepts is very similar to stratified LD score regression.  
The main difference is torus has a notion of "loci".  I'll be using the ldetect_EUR regions as windows.


*** Enrichment Analysis

*** Effect-Size Enrichment Analysis

Deterministic Approximation of Posteriors (DAP) is a method for estimating the posterior probability that a candidate GWAS SNP is a causal variant, 


#+BEGIN_SRC R :mkdirp :tangle ../scripts/gen_torus_sumstats.R

  library(readr)
  library(dplyr)
  library(purrr)
  library(forcats)
  library(ldmap)
  library(EigenH5)


  data(ldetect_EUR)


  sumstat_h5f <- snakemake@input[["inputf"]]
  snplist <- snakemake@input[["snplist"]]
  chromlist <- snakemake@params[["chroms"]]
  outputf <- snakemake@output[["outputf"]]

  chrom_df <- read_df_h5(sumstat_h5f, "chrom_offset") %>% 
    dplyr::slice(1:22) %>% 
    dplyr::mutate(offset = as.integer(offset),
                  datasize = as.integer(datasize)) %>%
    dplyr::arrange(offset)

  bc <- bim_cols(chrom=col_chromosome(prefix_chr=FALSE))
  index_l <- purrr::map(snplist, ~read_plink_bim(.x,cols = bc)$snp_struct)
  mutate(chrom_df,snplist_l = index_l) %>%
    pwalk(
      function(chrom, offset, datasize, snplist_l, ...) {
        fe <- file.exists(outputf)
        idf <- EigenH5::read_df_h5(
                          filename = sumstat_h5f,
                          datapath = "snp",
                          subcols = c("snp_struct", "beta", "se"),
                          offset = offset,
                          datasize = datasize) %>%
          match_ref_panel(snplist_l) %>%
          filter(!is.na(index)) %>% 
          dplyr::transmute(SNP = match,
                           locus = snp_in_region(SNP, ldetect_EUR),
                           `z-vals` =  beta / se )
        stopifnot(all(!is.na(idf$locus)))


        write_delim(idf,outputf, delim = " ",append = fe)
      })

#+END_SRC 



#+BEGIN_SRC R :mkdirp :tangle ../scripts/gen_torus_anno.R


  library(readr)
  library(dplyr)
  library(purrr)
  library(forcats)
  library(ldmap)


  data(ldetect_EUR)



  annof <- snakemake@input[["annot_f"]]
  index_f <- snakemake@input[["bimf"]]

  anno_n <- snakemake@params[["annot"]]
  chromlist <- snakemake@params[["chroms"]]
  outputf <- snakemake@output[["outputf"]]

  region_l <- purrr::map(annof, ~read_bed(.x)$ldmap_region)
  if (length(anno_n) > 0) {
    names(region_l) <- paste0(anno_n,"_d")
    bc <- bim_cols(chrom = col_chromosome(prefix_chr=FALSE))
    index_l <- purrr::walk(index_f, function(x) {
      fe <- file.exists(outputf)
      input_b <- read_plink_bim(x, cols = bc)$snp_struct
      snp_in_regions(input_b, region_l) %>%
        rename(SNP = ldmap_snp) %>%
        write_delim(outputf, delim = " ", append = fe)
    })
  }else {
    tibble::tibble(SNP = character()) %>% write_delim(outputf, delim = " ")
  }
#+END_SRC 



#+BEGIN_SRC R :mkdirp :tangle ../scripts/run_torus_fdr.R

cat("starting!\n")
library(daprcpp)

saveRDS(torus_fdr(snakemake@input[["gwasf"]],snakemake@input[["annof"]]),snakemake@output[["outputf"]])

#+END_SRC


#+BEGIN_SRC R :mkdirp :tangle ../scripts/filter_torus_p.R
    library(dplyr)
    library(purrr)
    library(readr)
    fdrc <- as.numeric(snakemake@params[["fdrc"]] %||% "0.1")
    fdrff <- snakemake@input[["fdrf"]]
    readRDS(fdrff) %>% 
      filter(fdr <= fdrc)  %>%
      select(region_id) %>%
      write_tsv(snakemake@output[["off"]], col_names = FALSE)

#+END_SRC 


#+BEGIN_SRC R :mkdirp :tangle ../scripts/ldmap_gwas.R

  library(EigenH5)
  library(ldmap)
  library(dplyr)
  data(ldetect_EUR)
  inputf <- snakemake@input[["inputf"]]
  cdf <- read_df_h5(inputf,"chrom_offset") %>% slice(1:22) 
  cds <- as.integer(sum(cdf$datasize))

  iv <- read_vector_h5(inputf, "snp/snp_struct", 1L:cds)
  ldi <- snp_in_region(iv, ldetect_EUR)
  rle2offset(ldi) %>% 
    rename(region_id=value) %>%
    mutate(offset=as.integer(offset)) %>% 
    saveRDS(snakemake@output[["offsetf"]])

#+END_SRC


#+BEGIN_SRC R :mkdirp :tangle ../scripts/ldmap_h5.R

  library(bigsnpr)
  library(fs)
  library(EigenH5)
  library(ldmap)
  library(dplyr)
  library(purrr)

  iff <- snakemake@input[["bedlist"]]
  off <- snakemake@output[["h5"]]
  bed2h5 <- function(inputf, outputf){
    td <- tempdir()
    pext <- fs::path_file(inputf)
    pext <- fs::path_ext_remove(pext)
    tbf <- fs::path(td, pext)
    rds <- snp_readBed(inputf, backingfile = tbf)

    bs <- bigsnpr::snp_attach(rds)
    tibble::as_tibble(bs$map) %>%
      dplyr::mutate(index = 1:dplyr::n()) %>%
      compact_snp_struct(chrom =  "chromosome",
                         pos =  "physical.pos",
                         ref = "allele2",
                         alt = "allele1",
                         remove = TRUE) %>%
      write_df_h5(outputf,"snp")
  
    bsx <- bs$genotypes
    bsxm <- bsx[,]
    write_matrix_h5(bsxm, outputf, "dosage")
    return(outputf)
  }

  bed2h5(iff,off)
  



#+END_SRC

#+RESULTS:


#+BEGIN_SRC R :mkdirp :tangle ../scripts/ldmap_ld.R


  library(EigenH5)
  library(ldmap)
  library(dplyr)
  library(purrr)

  data(ldetect_EUR)
  rdsf <- unlist(snakemake@input)
  stopifnot(!is.null(rdsf), file.exists(rdsf))

  ldmrfun <- function(snakemake) {
      ld_id <- snakemake@params[["region"]]
      if (is.null(ld_id)) {
          ichrom <- snakemake@params[["chrom"]]
          istart <- snakemake@params[["start"]]
          iend <- snakemake@params[["end"]]
          stopifnot(
              !is.null(ichrom),
              !is.null(istart),
              !is.null(iend),
              !is.na(as.integer(ichrom)),
              !is.na(as.integer(istart)),
              !is.na(as.integer(iend))
          )
          ldmr <- new_ldmap_region(
              as.integer(ichrom),
              as.integer(istart),
              as.integer(iend)
          )
      } else {
          stopifnot(!is.null(ld_id), length(ld_id) == 1)
          ld_id <- as.integer(ld_id)
          ldmr <- ldetect_EUR[ld_id]
      }
      return(ldmr)
  }
  ldmr <- ldmrfun(snakemake)


  init_fn <- function(reference_files, ldmr) {
      return(reference_files)
  }
  filter_map_fn <- function(reference_file, ldmr) {
      dplyr::filter(read_df_h5(reference_file, "snp"), snp_struct %overlaps% ldmr)
  }
  filter_geno_fn <- function(reference_file, ldmr, map) {
      read_matrix_h5v(reference_file, "dosage", j = map$index)
  }
  write_fn <- function(map, bsx, output_file) {
      write_df_h5(map, output_file, "snp")
      write_matrix_h5(bsx, output_file, "dosage")
      return(output_file)
  }
  read_map_fn <- function(x) {
      read_df_h5(x, "snp")
  }
  read_dosage_fn <- function(x, ...) {
      read_matrix_h5v(x, "dosage")
  }
  srds <- ldmap::subset_rds(
      ldmr = ldmr,
      reference_files = rdsf,
      output_file = snakemake@output[["ldf"]],
      init_fn = init_fn,
      filter_map_fn = filter_map_fn,
      filter_geno_fn = filter_geno_fn,
      write_fn = write_fn
  )
  print(srds)
  retR <- panel_ld(srds,
      LDshrink = FALSE,
      read_map_fn = read_map_fn,
      read_dosage_fn = read_dosage_fn
  )
  attr(retR, "dimnames") <- NULL
  EigenH5::write_matrix_h5(retR, snakemake@output[["ldf"]], datapath = "R")
#+END_SRC


#+BEGIN_SRC R :mkdirp :tangle ../scripts/run_torus_p.R
  library(daprcpp)
  library(dplyr)
  library(purrr)
  library(readr)
  library(ldmap)
  library(fs)
  library(tidyr)
  library(stringr)


  gf <- snakemake@input[["gwasf"]]
  af <- snakemake@input[["annof"]]
  if(is.null(af)){
  af <- tempfile()
  write_tsv(tibble::tibble(SNP=character()),af)
  }

  prior_rf <- snakemake@input[["prior_r"]]

    prior_r <- scan(prior_rf,what = character())
    od <- snakemake@output[["outputd"]]
    torus_ret <- daprcpp:::run_torus_cmd(gf=gf,af=af,torus_p=prior_r)

    saveRDS(torus_ret$df,snakemake@output[["outputf"]])
  if (!dir.exists(od)) {
    fs::dir_create(od,recurse = TRUE)
    }
    iwalk(torus_ret$priors,function(pr,region_id) {
    trid <- region_id
    separate(pr,SNP,c("chrom","pos","ref","alt"),convert=TRUE) %>%
      dplyr::mutate(chrom=as.integer(stringr::str_replace(chrom,"chr",""))) %>%
      compact_snp_struct(snp_struct="SNP") %>% 
      saveRDS(fs::path(od,trid,ext = "RDS"))
    })


#+END_SRC

#+RESULTS:

#+BEGIN_SRC R :mkdirp :tangle ../scripts/susie_r.R

    library(ldmap)
    library(EigenH5)
    library(susieR)
    library(dplyr)
    library(purrr)

  ldmrfun <- function(snakemake){
    ld_id <- snakemake@params[["region"]]
    if(is.null(ld_id)){
      ichrom <- snakemake@params[["chrom"]]
      istart <- snakemake@params[["start"]]
      iend <- snakemake@params[["end"]]
      stopifnot(!is.null(ichrom),
                !is.null(istart),
                !is.null(iend),
                !is.na(as.integer(ichrom)),
                !is.na(as.integer(istart)),
                !is.na(as.integer(iend)))
      ldmr <- new_ldmap_region(as.integer(ichrom),
                               as.integer(istart),
                               as.integer(iend))

    }else{
      stopifnot(!is.null(ld_id),
                length(ld_id)==1)
      ld_id <- as.integer(ld_id)
      ldmr <- ldetect_EUR[ld_id]
    }
    return(ldmr)
  }
  ldmr <- ldmrfun(snakemake)


  align_reference <- function(gwas_df,
                              reference_file,
                              remove_missing = TRUE,
                              read_map_fn = identity) {
        bsmap <- read_map_fn(reference_file)
        ret_df <- match_ref_panel(gwas_df,
                                  bsmap$snp_struct,
                                  remove_missing = remove_missing)
        stopifnot(all(!is.na(ret_df$index)))
        return(ret_df)
  }

  read_map_fn <- function(x) read_df_h5(x, "snp")


  p <- dim_h5(snakemake@input[["inputf"]], "snp/snp_struct")
  gwas_df <- read_df_h5(snakemake@input[["inputf"]],
                        datapath = "snp",
                        subcols = c("snp _struct", "beta", "se", "N"),
                        offset = ld_regions$offset,
                        datasize = ld_regions$datasize
                        ) %>%
    align_reference(snakemake@input[["ldf"]], read_map_fn = read_map_fn) %>%
    arrange(index)

  R <- read_matrix_h5v(snakemake@input[["ldf"]],
                       "R",
                       gwas_df$index,
                       gwas_df$index)


    gwas_df <- readRDS(snakemake@input[["priorf"]]) %>%
        select(snp_struct = SNP, prior) %>%
        inner_join(gwas_df)
    h <- 0.1
    h_p <- h / p
    prior_v <- h_p * nrow(gwas_df)
    sres <- susie_suff_stat(
        bhat = gwas_df$beta,
        shat = gwas_df$se,
        R = R,
        n = max(gwas_df$N),
        scaled_prior_variance = prior_v,
        prior_weights = gwas_df$prior,
        L = 1,
        null_weight = NULL
    )
    saveRDS(sres, snakemake@output[["outputf"]])
#+END_SRC

#+RESULTS:

#+BEGIN_SRC snakemake :mkdirp :tangle ../workflow/gwas_snakefile

  rule gwas_h52torus:
      input:
          inputf=config_d['GWAS'] +"{gwas}_gwas.h5",
          snplist = expand(config_d['1KG'] +"1000G_EUR_Phase3_plink/1000G.EUR.QC.{chrom}.bim",chrom=range(1,23))
      output:
          outputf=config_d['GWAS'] +"{gwas}_torus.txt.gz"
      conda:
          config_e['r']
      script:
          "../scripts/gen_torus_sumstats.R"

  def get_annot_torus_files(wildcards):

      wca = wildcards.anno_name
      if wca != 'null':
          annok = all_annot['ptb_torus_model'].get(wca)
          ret_dict = {
              'annot_f' : anno_files(annok),
              'bimf': expand(config_d['1KG'] +"1000G_EUR_Phase3_plink/1000G.EUR.QC.{chrom}.bim",chrom=range(1,23))
          }
      else:
          annok = all_annot['ptb_torus_model'].get(wca)
          ret_dict = {
              'bimf': expand(config_d['1KG'] +"1000G_EUR_Phase3_plink/1000G.EUR.QC.{chrom}.bim",chrom=range(1,23))
          }
      return ret_dict

  rule anno2torus:
      input:
          unpack(get_annot_torus_files)
      output:
          outputf=config_d['ANNO'] +"{anno_name}.txt.gz"
      params:
          chroms=range(1,22),
          annot=lambda wildcards: expand("{anno_name}",anno_name=all_annot['ptb_torus_model'][wildcards.anno_name]) if wildcards.anno_name != "null" else None
      conda:
          config_e['r']
      script:
          "../scripts/gen_torus_anno.R"

  rule anno2torus_fdr:
      input:
          gwasf=config_d['GWAS'] +"{gwas}_torus.txt.gz",
          annof=config_d['ANNO'] +"{anno_name}.txt.gz"
      output:
          outputf="torus_{gwas}_{anno_name}_fdr.RDS"
      conda:
          config_e['r']
      script:
          "../scripts/run_torus_fdr.R"


  rule torus_fdrf:
      input:
          fdrf="torus_{gwas}_{anno_name}_fdr.RDS"
      params:
          fdrc=0.1
      output:
          off="torus_{gwas}_{anno_name}_fdr.tsv"
      script:
          "../scripts/filter_torus_p.R"


  rule ldmap_bk:
      input:
          bimlist = config_d['1KG'] +"1000G_EUR_Phase3_plink/1000G.EUR.QC.{chrom}.bim",
          bedlist = config_d['1KG'] +"1000G_EUR_Phase3_plink/1000G.EUR.QC.{chrom}.bed"
      output:
          h5 = config_d['1KG'] +"1000G_EUR_Phase3_plink/h5/1000G.EUR.QC.{chrom}.h5"
      script:
          "../scripts/ldmap_h5.R"

  rule ldmap_gwas:
      input:
          inputf=config_d['GWAS'] +"{gwas}_gwas.h5"
      output:
          offsetf=config_d['GWAS'] +"{gwas}_gwas_ldetect.RDS"
      script:
         "../scripts/ldmap_gwas.R"

  def ldmap_rf(wildcards):
      rchrom = ldetect_data[int(wildcards.region_id)]['chrom']
      return config_d['1KG'] +f"1000G_EUR_Phase3_plink/h5/1000G.EUR.QC.{rchrom}.h5"


  rule ldmap_ld_reg:
      input:
          config_d['1KG'] +f"1000G_EUR_Phase3_plink/h5/1000G.EUR.QC.{chrom}.h5"
      params:
          chrom="{chrom}",
          start="{start}",
          end="{end}"
      output:
          ldf = config_d['1KG'] +"1000G_EUR_Phase3_plink/LDR/{chrom}_{start}_{end}.h5"
      script:
          "../scripts/ldmap_ld.R"


  rule ldmap_ld:
      input:
          ldmap_rf
      params:
          region="{region_id}"
      output:
          ldf = config_d['1KG'] +"1000G_EUR_Phase3_plink/LD/{chrom}_{region_id}.h5"
      script:
          "../scripts/ldmap_ld.R"


  checkpoint anno2torusp:
      input:
          gwasf=config_d['GWAS'] +"{gwas}_torus.txt.gz",
          annof=config_d['ANNO'] +"{anno_name}.txt.gz",
          prior_r="torus_{gwas}_{anno_name}_fdr.tsv"
      output:
          outputf="torus_{gwas}_{anno_name}_mv.RDS",
          outputd=directory(config_d['ANNO'] +"torus_{gwas}_{anno_name}")
      conda:
          config_e['r']
      script:
          "../scripts/run_torus_p.R"


  # checkpoint anno2torusN:
  #     input:
  #         gwasf=config_d['GWAS'] +"ptb_torus.txt.gz",
  #         prior_r="torus_ptb_allhic_fdr.tsv"
  #     output:
  #         outputf="torus_ptb_mv.RDS",
  #         outputd=directory(config_d['ANNO'] +"torus_ptb")
  #     conda:
  #         config_e['r']
  #     script:
  #         "../scripts/run_torus_p.R"


#+END_SRC


#+BEGIN_SRC R :tangle ../scripts/gen_susie_prior.R
  library(ldmap)
  library(dplyr)
  library(purrr)
  library(readr)


  ld_id <- snakemake@params[["region"]]
  if(is.null(ld_id)){
    ichrom <- snakemake@params[["chrom"]]
    istart <- snakemake@params[["start"]]
    iend <- snakemake@params[["end"]]
    stopifnot(!is.null(ichrom),
              !is.null(istart),
              !is.null(iend),
              !is.na(as.integer(ichrom)),
              !is.na(as.integer(istart)),
              !is.na(as.integer(iend)))
    ldmr <- new_ldmap_region(as.integer(ichrom),
                             as.integer(istart),
                             as.integer(iend))

  }else{
    stopifnot(!is.null(ld_id),
              length(ld_id) == 1)
    ld_id <- as.integer(ld_id)
    ldmr <- ldetect_EUR[ld_id]
  }

  mvpf <- snakemake@input[["mvp"]]
  annof <- snakemake@input[["annof"]]
  outf <- snakemake@output[["outf"]]
  stopifnot(!is.null(outf),
            !is.null(mvpf),
            !is.null(annof),
            file.exists(annof),
            file.exists(mvpf))

  mvd <- readRDS(mvpf) %>%
    unnest(data) %>%
    select(term,estimate)

  annodf <- read_delim(annof,delim=" ") %>%
    mutate(SNP=ldmap:::parse_ldmap_SNP(SNP)) %>%
    filter(SNP %overlaps% ldmr)


  intercept <- filter(mvd,term=="Intercept") %>%
    pull(estimate)

  pivot_longer(annodf,
      cols = c(-SNP),
      names_to = c("term"),
      values_to = c("anno")
  ) %>%
      mutate(term = stringr::str_remove(term, "_d$")) %>%
      inner_join(mvd) %>%
      group_by(SNP) %>%
      summarise(prior = 1 / (1 <- exp(-(intercept + sum(anno * estimate))))) %>%
      saveRDS(outf)





#+END_SRC


#+BEGIN_SRC snakemake  :tangle ../workflow/gwas_snakefile


  rule susie_p:
      input:
          unpack(susie_p_files)
      params:
          region_id="{region_id}"
      output:
          outputf=config_d['FINEMAP']+"torus_{gwas}_{anno_name}/{region_id}.RDS"
      script:
          "../scripts/susie_r.R"

  rule torus_anno_r:
      input:
          annof=config_d['ANNO'] +"{anno_name}.txt.gz",
          mvp="torus_{gwas}_{anno_name}_mv.RDS"
      params:
          chrom="{chrom}",
          start="{start}",
          end="{end}"
      output:
          outf=config_d['FINEMAP']+"/prior_{gwas}_{anno_name}/{chrom}_{start}_{end}.RDS"
      script:
          "../scripts/gen_susie_prior.R"
    
        
  rule susie_pr:
      input:
          ldf=config_d['1KG'] +f"1000G_EUR_Phase3_plink/LDR/{chrom}_{start}_{end}.h5",
          ldgf=config_d['GWAS']+ f"{gwas}_gwas_ldetect.RDS",
          priorf=config_d['ANNO'] +f"/prior_{gwas}_{anno_name}/{chrom}_{start}_{end}.RDS",
          inputf=config_d['GWAS'] +f"{gwas}_gwas.h5"
      params:
          chrom="{chrom}",
          start="{start}",
          end="{end}"
      output:
          outputf=config_d['FINEMAP']+"/susie_{gwas}_{anno_name}/{chrom}_{start}_{end}.RDS"
      script:
          "../scripts/susie_r.R"        



  def susie_pn_files(wildcards):
        rchrom = ldetect_data[int(wildcards.region_id)-1]['chrom']
        region_id = wildcards.region_id
        gwas = "ptb"
        print(wildcards)
        ldf = config_d['1KG'] +f"1000G_EUR_Phase3_plink/LD/{rchrom}_{region_id}.h5",
        ldgf=config_d['GWAS']+ f"{gwas}_gwas_ldetect.RDS",
        priorf=config_d['ANNO'] +f"torus_{gwas}/{region_id}.RDS",
        inputf=config_d['GWAS'] +f"{gwas}_gwas.h5"
        ret_dict = {
              'ldf': ldf,
              'ldgf': ldgf,
              'priorf': priorf,
              'inputf':inputf
        }
        return ret_dict




  rule susie_pn:
      input:
          unpack(susie_pn_files)
      params:
          region_id="{region_id}"
      output:
          outputf=config_d['FINEMAP']+"torus_ptb/{region_id}.RDS"
      script:
          "../scripts/susie_r.R"



  def aggregate_input(wildcards):
      checkpoint_output = checkpoints.anno2torusp.get(**wildcards).output['outputd']
      print("cpo:"+checkpoint_output)
      return expand(config_d['FINEMAP']+"torus_{gwas}_{anno_name}/{i}.RDS",
                    gwas=wildcards.gwas,
                    anno_name=wildcards.anno_name,
                    i=glob_wildcards(os.path.join(checkpoint_output, "{i}.RDS")).i)

  def aggregate_inputN(wildcards):
      checkpoint_output = checkpoints.anno2torusN.get(**wildcards).output['outputd']
      print("cpo:"+checkpoint_output)
      return expand(config_d['FINEMAP']+"torus_ptb/{i}.RDS",
                    i=glob_wildcards(os.path.join(checkpoint_output, "{i}.RDS")).i)


#+END_SRC



#+BEGIN_SRC R :mkdirp :tangle ../scripts/agg_susie.R
#source("renv/activate.R")
cat(paste(unlist(snakemake@input),collapse="\n"))
saveRDS(purrr::map(unlist(snakemake@input),readRDS),snakemake@output[["outputf"]])

#+END_SRC


#+BEGIN_SRC snakemake :mkdirp :tangle ../workflow/gwas_snakefile
  rule comb_susie:
        input:
            aggregate_input
        output:
            outputf="aggregated/{gwas}_{anno_name}.RDS"
        script:
            "../scripts/agg_susie.R"


  rule comb_susieN:
        input:
            aggregate_inputN
        output:
            outputf="aggregated/ptbNULL.RDS"
        script:
            "../scripts/agg_susie.R"


#+END_SRC


** Running FastQTL 


#+BEGIN_SRC snakemake :mkdirp :tangle ../workflow/eqtl_snakefile
  rule prep_covars:
      input:
          config_d['OBERF']+'covariates/AllColumnNames_final53_PC.txt.gz'
      params:
          HL = lambda wildcards: str(int(wildcards.PCN)+13)
      output:
          config_d['OBERF']+'covariates/covarlist_{PCN}.txt.gz'
      shell:
          "zcat {input} | head -n {params.HL} | gzip -c > {output}"

  rule fix_vcf:
      input:
          vcf=config_d['OBERF']+"genotypes/chr{chrom}.dose.vcf.gz",
          samples=config_d['OBERF']+"new_id.txt"
      output:
          vcf=config_d['OBERF']+"genotypes/new_chr{chrom}.dose.vcf.gz"
      params:
          bcft="/gpfs/data/xhe-lab/software/spack/opt/spack/linux-redhatenterprisecomputenode6-haswell/gcc-9.2.0/bcftools-1.9-goevgxsrdzddc35cwrixhankcktu4xfj/bin/bcftools"
      shell:
          "{params.bcft} reheader --samples {input.samples} {input.vcf} -o {output.vcf}"

  rule idx_vcf:
      input:
          vcf=config_d['OBERF']+"genotypes/new_chr{chrom}.dose.vcf.gz"
      output:
          idx=config_d['OBERF']+"genotypes/new_chr{chrom}.dose.vcf.gz.tbi"
      shell:
          "/gpfs/data/xhe-lab/software/spack/opt/spack/linux-rhel6-haswell/gcc-9.2.0/htslib-1.9-j2ibkw6g7h4v6a5umnfhuwyyk34aldr5/bin/tabix {input.vcf}"


  def format_ldch(elem):
      return str(elem['chrom'])+":"+str(elem['start'])+'-'+str(elem['end'])

  def ldmap_rf(wildcards):
      rchrom = ldetect_data[int(wildcards.region_id)]['chrom']
      return config_d['1KG'] +f"1000G_EUR_Phase3_plink/h5/1000G.EUR.QC.{rchrom}.h5"

  rule run_fastqtl_region:
      input:
          exp=config_d['OBERF']+'phenotypes/Final_GeneExprDetected.7.bed.gz',
          cov=expand(config_d['OBERF']+'covariates/covarlist_{PCN}.txt.gz',PCN=range(5))
          samples=config_d['OBERF']+'samples.txt',
          vcf=lambda wildcards: config_d['OBERF']+"genotypes/new_chr"+str(ldetect_data[int(wildcards.region_id)]['chrom'])+".dose.vcf.gz",
          vcfi=lambda wildcards: config_d['OBERF']+"genotypes/new_chr"+str(ldetect_data[int(wildcards.region_id)]['chrom'])+".dose.vcf.gz.tbi"
      output:
          outputf=config_d['OBERF']+'output/{region_id}_{PCN}.txt.gz'
      params:
          region = lambda wildcards: format_ldch(ldetect_data[int(wildcards.region_id)])
      shell:
          "/gpfs/data/xhe-lab/software/spack/opt/spack/linux-rhel6-haswell/gcc-9.2.0/yesterdayqtl-master-wpcshqtonksv576xlubn5bejtx3vm5ci/bin/fastqtl --vcf {input.vcf} --bed {input.exp} --cov {input.cov} --out {output} -R {params.region} --include-samples {input.samples} "


  # rule run_fastqtl_gata2:
  #     input:
  #         vcf=config_d['OBERF']+'genotypes/new_chr3.dose.vcf.gz',
  #         exp=config_d['OBERF']+'phenotypes/Final_GeneExprDetected.7.bed.gz',
  #         cov=config_d['OBERF']+'covariates/covarlist_{PCN}.txt.gz',
  #         samples=config_d['OBERF']+'samples.txt'
  #     output:
  #         outputf="fastqtl/GATA2_{PCN}.txt"
  #     shell:
  #         "/gpfs/data/xhe-lab/software/spack/opt/spack/linux-rhel6-haswell/gcc-9.2.0/yesterdayqtl-master-wpcshqtonksv576xlubn5bejtx3vm5ci/bin/fastqtl --vcf {input.vcf} --bed {input.exp} --cov {input.cov} --out {output} -R 3:128194861-130244735 --include-samples {input.samples} "


  # rule run_fastqtl_hand2:
  #     input:
  #         vcf=config_d['OBERF']+'genotypes/new_chr4.dose.vcf.gz',
  #         exp=config_d['OBERF']+'phenotypes/Final_GeneExprDetected.7.bed.gz',
  #         cov=config_d['OBERF']+'covariates/covarlist_{PCN}.txt.gz',
  #         samples=config_d['OBERF']+'samples.txt'
  #     output:
  #         outputf="fastqtl/HAND2_{PCN}.txt"
  #     shell:
  #         "/gpfs/data/xhe-lab/software/spack/opt/spack/linux-rhel6-haswell/gcc-9.2.0/yesterdayqtl-master-wpcshqtonksv576xlubn5bejtx3vm5ci/bin/fastqtl --vcf {input.vcf} --bed {input.exp} --cov {input.cov} --out {output} -R 4:174264132-176570716 --include-samples {input.samples}"

#+END_SRC



** fine mapping with eqtl data

#+BEGIN_SRC R 

  library(tidyverse)
  library(fs)
  library(ldmap)
  fmap_df <- readRDS("/home/nwknoblauch/Dropbox/scratch/ptb_scratch/ptb_utme3treatedhic.RDS")
  ## fmap_f <- dir_ls(fmap_d,regexp="ptb")
  ## fmap_fdf <- tibble(path=fmap_f,file=fs::path_file(path)) %>%
  ##   filter(str_detect(file,"^ptb_")) %>% 
  ##   mutate(type=if_else(str_detect(file,"hic",negate=TRUE), "Null",
  ##                       str_replace(file,"ptb_([a-z]+)_([0-9]+).RDS","\\1")))
  ## nulldf <- readRDS(fmap_f[1])


#+END_SRC

** Generating Plots

#+BEGIN_SRC snakemake  :tangle ../workflow/plot_snakefile

  def gene_reg(wildcards):
      rchrom = ldetect_data[int(wildcards.region_id)-1]['chrom']
      start = ldetect_data[int(wildcards.region_id)-1]['start']
      stop = ldetect_data[int(wildcards.region_id)-1]['end']
      ret_dict = { 'chrom': 'chr'+str(rchrom),
                   'start': start,
                   'end': stop}
      return ret_dict


  rule gene_plot:
        params:
            gene_reg
        output:
            outputf="results/plot_data/genes/{region_id}.RDS",
            genelistf="results/plot_data/genes/{region_id}_genelist.txt.gz"
        script:
            "../scripts/ldmr_geneplot_data.R"


  def anno_plot_fun(wildcards):
      anno_name = wildcards.anno_name
      region_id = wildcards.region_id
      hicm = re.compile('^hic')
      annol = all_annot['ptb_torus_model'].get(anno_name)
      print(annol)
      annok = [x for x in annol if not hicm.match(x)]
      ret_dict = {
          'annof' : anno_files(annok )
      }
      return ret_dict


  rule anno_data_plot:
      input:
          unpack(anno_plot_fun)
      params:
          anno_names= lambda wildcards: [x for x in all_annot['ptb_torus_model'].get(wildcards.anno_name) if not re.compile('^hic').match(x)],
          region_id="{region_id}"
      output:
          anno="results/plot_data/anno/{anno_name}_{region_id}.RDS"
      script:
          "../scripts/ldmr_annoplot_data.R"



  rule gwas_p_data_plot:
      input:
          pipf = config_d['FINEMAP']+"torus_{gwas}_{anno_name}/{region_id}.RDS",
          gwasf = config_d['GWAS'] +"{gwas}_gwas.h5",
          ldgf = config_d['GWAS']+ "{gwas}_gwas_ldetect.RDS",
          priorf = config_d['ANNO'] +"torus_{gwas}_{anno_name}/{region_id}.RDS"
      params:
          region_id="{region_id}"
      output:
          gwas="results/plot_data/susie/{gwas}_{anno_name}_{region_id}.RDS"
      script:
          "../scripts/ldmr_pplot_data.R"

  rule gwas_np_data_plot:
      input:
          pipf = config_d['FINEMAP']+"torus_ptb/{region_id}.RDS",
          gwasf = config_d['GWAS'] +"ptb_gwas.h5",
          ldgf = config_d['GWAS']+ "ptb_gwas_ldetect.RDS",
          priorf = config_d['ANNO'] +"torus_ptb/{region_id}.RDS"
      params:
          region_id="{region_id}"
      output:
          gwas="plot_data/susie/ptb_{region_id}.RDS"
      script:
          "../scripts/ldmr_pplot_data.R"



  rule hic_data_plot:
      input:
          hic=config_d['BED']+"DT1_dTL4_D_48h.ibed.bz2"
      params:
          region_id="{region_id}"
      output:
          hic="plot_data/hic/{region_id}.RDS"
      script:
          "../scripts/ldmr_hicplot_data.R"




  def ldplot(wildcards):
      regid = int(wildcards.region_id)
      rchrom = ldetect_data[regid]['chrom']
      return {'ldhf': config_d['1KG']+f"1000G_EUR_Phase3_plink/LD/{rchrom}_{regid}.h5"}


  rule ld_data_plot:
      input:
          unpack(ldplot)
      params:
          region_id="{region_id}"
      output:
          plotf="plot/LD/{region_id}.RDS",
          dataf="plot_data/LD/{region_id}.RDS"
      script:
          "../scripts/ldmr_ldplot.R"


#+END_SRC

#+BEGIN_SRC R :mkdirp :tangle ../scripts/ldmr_ldplot.R

  library(dplyr)
  library(tidyr)
  library(purrr)
  library(ggplot2)
  library(ldmap)
  library(EigenH5)
  library(Matrix)

  inputf <- snakemake@input[["ldhf"]]


  saveRDS(filter(df,r2 > 0.1),snakemake@output[["dataf"]])
  ld_plot  <- filter(df,r2 > 0.1) %>% ggplot() +
    geom_point(aes(positions(isnp) + y, y, color = r2, alpha = r2), size = rel(0.5)) +
    theme(axis.text.y = element_blank(),
          axis.ticks.y = element_blank()) +
    labs(x = "Position", y = NULL) +
    scale_alpha(guide = 'none')
  saveRDS(ld_plot,snakemake@output[["plotf"]])


#+END_SRC


*** Gene data

#+BEGIN_SRC R :mkdirp :tangle ../scripts/ldmr_geneplot_data.R

#  #source("renv/activate.R")
  library(stringr)
  library(Homo.sapiens)
  library(RColorBrewer)

  library(purrr)
  library(dplyr)
  library(biovizBase)
  library(Homo.sapiens)
  library(readr)

  txdb <- TxDb(Homo.sapiens)

  chrp <- snakemake@params[[1]][["chrom"]]
  stopifnot(!is.null(chrp))

  start <- snakemake@params[[1]][["start"]]
  stopifnot(!is.null(start))
  start <- as.integer(start)

  end <- snakemake@params[[1]][["end"]]
  stopifnot(!is.null(end))
  end <- as.integer(end)

  gr <- GenomicRanges::GRanges(seqnames = chrp,ranges=IRanges::IRanges(start = start,end = end))

  suppressMessages(tg_df <-
                     OrganismDbi::selectByRanges(
                                    x = Homo.sapiens,
                                    ranges = gr,
                                    columns = c("SYMBOL", "TXNAME")) %>%
                     as_tibble() %>%
                     dplyr::select(tx_name = TXNAME, symbol = SYMBOL) %>%
                     tidyr::unnest(cols = c(tx_name, symbol)))

  suppressMessages(gr.txdb <-
                     crunch(txdb, which = gr) %>%
                     as_tibble() %>%
                     mutate(tx_name = as.character(tx_name)) %>%
                     inner_join(tg_df) %>%
                     plyranges::as_granges() %>%
                     split(.$symbol))

  dplyr::as_tibble(tg_df) %>% distinct(symbol) %>% write_tsv(snakemake@output[["genelistf"]])
  saveRDS(unlist(gr.txdb),snakemake@output[["outputf"]])


#+END_SRC

*** Anno data

#+BEGIN_SRC R :mkdirp :tangle ../scripts/ldmr_annoplot_data.R


anno_files <- snakemake@input[["annof"]]
anno_names <- snakemake@params[["anno_names"]]
regid <- snakemake@params[["region_id"]]

  library(ldmap)
  library(stringr)
  library(EigenH5)
  library(tidyr)
  library(vroom)
  library(purrr)
  library(dplyr)

  anno_dff <- function(anno_files, anno_names, ldmrid) {
    map2_dfr(anno_files, anno_names, function(x, y) {
      read_bed(x, read_fun = purrr::partial(vroom::vroom, delim = "	")) %>%
        dplyr::filter(region_in_region(ldmap_region, ldetect_EUR,TRUE) == ldmrid) %>%
        mutate(anno = y)
    }) %>% mutate(ldmap_region=as_ldmap_region(ldmap_region))
  }




  stopifnot(!is.null(regid))


  anno_result_df <- anno_dff(anno_files, anno_names, as.integer(regid))



  saveRDS(anno_result_df, snakemake@output[["anno"]])

#+END_SRC




#+BEGIN_SRC R :mkdirp :tangle ../scripts/ldmr_pplot_data.R


    pipf <- snakemake@input[["pipf"]]
    gwasf <- snakemake@input[["gwasf"]]
    ldgf <- snakemake@input[["ldgf"]]
    regid <- snakemake@params[["region_id"]]
    priorf <- snakemake@input[["priorf"]]


#    #source("renv/activate.R")
    library(stringr)
    library(EigenH5)
    library(ldmap)
    library(readr)
    library(tidyr)
    library(vroom)
    library(purrr)
    library(dplyr)



    merge_gwas_susie <- function(gwas_h5, ldetect_rds, susie_rds, ldmrid, prior_rds) {
        stopifnot(
            !is.null(gwas_h5),
            !is.null(ldetect_rds),
            !is.null(susie_rds),
            all(file.exists(c(
                gwas_h5,
                ldetect_rds,
                susie_rds
            )))
        )

        susie_res <- readRDS(susie_rds)
        ldr <- readRDS(ldetect_rds) %>% slice(ldmrid)
        gwas_df <- read_df_h5(gwas_h5,
            "snp",
            subcols = c("snp_struct", "pval"),
            offset = as.integer(ldr$offset),
            datasize = as.integer(ldr$datasize)
        )
        prior_df <- readRDS(prior_rds)
        if (typeof(prior_df$SNP) == "character") {
            prior_df <- prior_df %>%
                separate(SNP, c("chrom", "pos", "ref", "alt"), convert = TRUE) %>%
                dplyr::mutate(chrom = as.integer(stringr::str_replace(chrom, "chr", ""))) %>%
                compact_snp_struct(snp_struct = "SNP")
        }
        ret_match <- dplyr::bind_cols(gwas_df, join_snp(
            gwas_df$snp_struct,
            prior_df$SNP
        )) %>%
            filter(!is.na(index)) %>%
            dplyr::select(snp_struct = match, index, pval)
        ret_match$prior <- prior_df$prior[ret_match$index]

        stopifnot(
            all(snp_in_region(range(ret_match$snp_struct), ldetect_EUR) == ldmrid),
            length(susie_res$alpha) == nrow(ret_match)
        )
        ret_match <- dplyr::select(ret_match, -index) %>%
            dplyr::mutate(pip = susie_res$pip, CS = FALSE)
        if(length(susie_res$sets$cs)!=1)
          return(ret_match)
        stopifnot(length(susie_res$sets$cs) == 1)
        ret_match$CS[susie_res$sets$cs[[1]]] <- TRUE
        return(ret_match)
    }




    stopifnot(!is.null(regid))

    gwas_result_df <- merge_gwas_susie(gwasf, ldgf, pipf, as.integer(regid), priorf)

    saveRDS(gwas_result_df, snakemake@output[["gwas"]])

#+END_SRC




#+BEGIN_SRC R :mkdirp :tangle ../scripts/ldmr_hicplot_data.R

    hic_file <- snakemake@input[["hic"]]
    regid <- snakemake@params[["region_id"]]


#    #source("renv/activate.R")
    library(stringr)
    library(readr)
    library(EigenH5)
    library(ldmap)
    library(tidyr)
    library(vroom)
    library(purrr)
    library(dplyr)

    hic_anno_dff <- function(hic_file, ldmrid) {
        cold <- cols(
            bait_chr = col_factor(paste0("chr", c(as.character(1:22), c("X", "Y")))),
            bait_start = col_double(),
            bait_end = col_double(),
            bait_name = col_character(),
            otherEnd_chr = col_factor(paste0("chr", c(as.character(1:22), c("X", "Y")))),
            otherEnd_start = col_double(),
            otherEnd_end = col_double(),
            otherEnd_name = col_character(),
            N_reads = col_double(),
            score = col_double()
        )
        ldmr <- ldetect_EUR[ldmrid]
        read_tsv(hic_file, col_names = names(cold$cols), col_types = cold, skip = 1L) %>%
            filter(bait_chr != "chrY", otherEnd_chr != "chrY") %>%
            compact_ldmap_region(chrom = "bait_chr", start = "bait_start", end = "bait_end", ldmap_region = "bait") %>%
            compact_ldmap_region(chrom = "otherEnd_chr", start = "otherEnd_start", end = "otherEnd_end", ldmap_region = "target") %>%
            filter(!is.na(region_in_region(bait,ldmr,TRUE)), !is.na(region_in_region(target,ldmr,TRUE)))
    }

    stopifnot(!is.null(regid))

    hic_result_df <- hic_anno_dff(hic_file,as.integer(regid))

    saveRDS(hic_result_df, snakemake@output[["hic"]])
#+END_SRC


#+BEGIN_SRC R :mkdirp :tangle ../scripts/ldmr_hicplot.R
#  #source("renv/activate.R")

  library(stringr)
  library(readr)
  library(EigenH5)
  library(ldmap)
  library(tidyr)
  library(vroom)
  library(purrr)
  library(dplyr)

  anno_file <- snakemake@input[["anno_file"]]
  region <- snakemake@params[["region"]]
  hic_file <- snakemake@input[["hic"]]
  null_file <- snakemake@input[["null_file"]]
  alt_file <- snakemake@input[["alt_file"]]

  pip_df <- inner_join(readRDS(null_file),
                       readRDS(alt_file),
                       by = c("snp_struct","pval"),
                       suffix = c("_null","_model")) %>%
    mutate(region_id = region)

  tfr <- pip_df %>%
    dplyr::arrange(snp_struct) %>%
    dplyr::mutate(lrmax = pmin(cummax(pip_model),rev(cummax(rev(pip_model))))) %>%
     dplyr::filter(lrmax > 1e-6)  %>% dplyr::pull(snp_struct)  %>% convex_hull()

    cs_df <-  dplyr::filter(pip_df,CS_model==TRUE)

  anno_df <- readRDS(anno_file) %>%
      mutate(region_id = region) %>%
      dplyr::filter(is_region_in_region(ldmap_region, tfr))

  hic_df <- readRDS(hic_file) %>%
      dplyr::mutate(region_id = y) %>%
    dplyr::filter(is_region_in_region(bait, tfr), is_region_in_region(target, tfr))

  bait_df <- dplyr::select(hic_df, ldmap_region = bait,
                           region_id) %>%
    mutate(anno = "DSC_Treated_HiC")

  target_df <- dplyr::select(hic_df, ldmap_region = target,
                             region_id) %>%
    mutate(anno = "DSC_Treated_HiC")

  plot_df <- bind_rows(anno_df,
                       bait_df,
                       target_df) %>%
    mutate(ldmap_region = as_ldmap_region(ldmap_region))


  midpoints <- function(x) {
      stopifnot(inherits(x, "ldmap_region"))
      return(starts(x) + round((ends(x) - starts(x)) / 2))
  }
  widths <- function(x) {
      stopifnot(inherits(x, "ldmap_region"))
      return(ends(x) - starts(x))
  }

  hlinel <- map(positions(cd_df$snp_struct), ~ geom_vline(xintercept = .x, col = "red", alpha = 0.2))

  add_plots <- function(proto, plot_list) {
      purrr::reduce(plot_list, `+`, .init = proto)
  }

  hicplotf <- function(reg) {
      fl <- focus_l[[reg]]

      hml <- hlinemapl[[reg]]
      df <- focus_hic_l[[reg]]

      tannogr <- focus_full_anno_l[[reg]] %>% dplyr::mutate(
          feature = str_remove(anno, "^.+dec-"),
          feature = str_remove(feature, "DSC_Treated_"),
          feat_fact = factor(feature)
      )

      df <- dplyr::mutate(df, feat_fact = factor("HiC", levels = levels(tannogr$feat_fact)))

      annoplot <- ggplot() +
          geom_tile(
              data = tannogr,
              aes(
                  x = midpoints(ldmap_region),
                  y = feat_fact,
                  width = widths(ldmap_region)
              ),
              height = .5
          ) +
          geom_curve(data = df, aes(
              x = midpoints(bait),
              y = feat_fact,
              xend = midpoints(target),
              yend = feat_fact
          )) +
          ylab("Functional Genomic Annotation") +
          xlab("Position") +
          xlim(c(starts(fl), ends(fl)))
      add_plots(annoplot, hml)
  }

  genel <- map(havegene_list, function(reg) {
      fl <- focus_l[[reg]]
      x <- focus_grtm[[reg]]
      y <- hlinemapl[[reg]]
      add_plots(x@ggplot + ylab("Genes") + xlim(c(starts(fl), ends(fl))), y)
  })
  fmplots <- list(gene = genel, anno = hicplots, ld = lddfl_vl) %>% pmap(function(gene, anno, ld) {
      (anno / gene / ld)
  })
  plan(multiprocess)

  od <- "/home/nwknoblauch/Dropbox/MOD paper 1/Fine_Mapping/"
  future_walk(seq_along(fmplots), function(i) {
      plt <- fmplots[[i]]
      name <- havegene_list[i]
      output_png <- fs::path(name, ext = "png")
      ggsave(filename = output_png, plot = plt, path = od)
  })


    library(EigenH5)
    cols <- rev(grDevices::colorRampPalette(c("#41AB5D","#BDBDBD"),
                                    space = "Lab")(200))
    ld_files <- fs::dir_ls("~/tmp/LD/",glob="*h5")
    ld_region <- str_replace(ld_files,".+/[0-9]+_([0-9]+).h5","\\1")
    ldf_df <- tibble(inputf=ld_files,region=ld_region) %>% dplyr::filter(region %in% names(focus_l))
    lddfl <- pmap(ldf_df,function(inputf,region){
      tfoc <- focus_l[[region]]
      tmpdf <- read_df_h5(inputf,"snp")
      tmpR <- read_matrix_h5(inputf,"R")
      tmpT <- as(tmpR, "dgTMatrix")
      upper <- (tmpT@i <= tmpT@j)
      df <- tibble(
        i = tmpT@i[upper], 
        j = tmpT@j[upper],
        r2 = tmpT@x[upper]^2
      ) %>% 
        mutate(isnp = tmpdf$snp_struct[i + 1],jsnp = tmpdf$snp_struct[j + 1]) %>% filter(positions(i) <=  positions(j)) %>% 
        mutate(y = (positions(jsnp) - positions(isnp)) / 2) %>% 
        dplyr::filter(is_snp_in_region(isnp,tfoc),is_snp_in_region(jsnp,tfoc)) %>%
        ggplot() +
        geom_point(aes(positions(isnp) + y, y, color = r2, alpha = r2), size = rel(0.5)) +
        scale_color_gradientn(colours=cols) +
        theme(axis.text.y = element_blank(),
              axis.ticks.y = element_blank()) +
        labs(x = "Position", y = NULL) +
        scale_alpha(guide = 'none')
    }) %>% set_names(ldf_df$region)

      focus_gr_list <- map(focus_l,function(ldmr) {
          chrp  <- paste0("chr",chromosomes(ldmr))
          start <- starts(ldmr)
          end <- ends(ldmr)

          return(GenomicRanges::GRanges(seqnames = chrp,ranges=IRanges::IRanges(start = start,end = end)))
        })
        focus_tgdl <- map(focus_gr_list,function(gr) {
          suppressMessages(tg_df <-
                             OrganismDbi::selectByRanges(
                                            x = Homo.sapiens,
                                            ranges = gr,
                                            columns = c("SYMBOL", "TXNAME")) %>%
                             as_tibble() %>%
                             dplyr::select(tx_name = TXNAME, symbol = SYMBOL) %>%
                             tidyr::unnest(cols = c(tx_name, symbol)))
          return(tg_df)
        })

      genefun <- function(tg_df,gr) {
        if(nrow(tg_df)>0){
          suppressMessages(gr.txdb <-
                             crunch(txdb, which = gr) %>%
                             tibble::as_tibble() %>%
                             dplyr::mutate(tx_name = as.character(tx_name)) %>%
                             dplyr::inner_join(tg_df) %>%
                             plyranges::as_granges() %>%
                             split(.$symbol))
        }else{
          gr.txdb <- GenomicRangesList()
          return(gr.txdb)
        }
      }


      focus_grtl <- map2(focus_tgdl, focus_gr_list, genefun)  %>% purrr::discard(~class(.x)=="SimpleGenomicRangesList")
      focus_grtm <- map(focus_grtl,autoplot)
      length(focus_grtl)

    txdb <- TxDb(Homo.sapiens)

#+END_SRC

#+BEGIN_SRC R :mkdirp :tangle ../scripts/ldmr_bigwigplot.R
  input_st
  inputf <- dir("/tmp",pattern="*bw",full.names=TRUE)
  susie_d <- "/home/nwknoblauch/Dropbox/Repos/ptb_workflowr/output/results/plot_data/susie"
  susie_f <- "/home/nwknoblauch/Dropbox/Repos/ptb_workflowr/output/results/plot_data/susie/ptb_treatedhic_512.RDS"
  susie_nullf <- "/home/nwknoblauch/Dropbox/Repos/ptb_workflowr/output/results/plot_data/susie/ptb_512.RDS"

  pip_df <- dplyr::inner_join(readRDS(susie_nullf),
                       readRDS(susie_f),by = c("snp_struct","pval"),suffix = c("_null","_model"))
  f_pip_df <- pip_df %>%  dplyr::arrange(snp_struct) %>% dplyr::mutate(lrmax = pmin(cummax(pmax(pip_model,pip_null)),rev(cummax(rev(pmax(pip_null,pip_model))))))
  fm_region <- dplyr::filter(f_pip_df,lrmax > 1e-6)  %>% dplyr::pull(snp_struct)  %>% convex_hull()
  region_r <- fm_region
  x <- inputf[1]

  library(rtracklayer)
  library(ldmap)
  #library(ggnomics)
  library(fs)
  library(purrr)
  library(dplyr)
  library(stringr)
  library(plyranges)
  library(Gviz)


  library(biovizBase)
  library(Homo.sapiens)
  library(readr)


  #exp <- example_HiC()
  #inputf <- snakemake@input[["bigwigs"]]
  fnames <- fs::path_ext_remove((fs::path_file(inputf)))
  mark <-  str_remove(fnames,"DSC[0-9]-.+-")
  treatment <-  str_replace(fnames,"DSC[0-9]-(.+)-.+","\\1")
  (sample <-  str_replace(fnames,"(DSC[0-9])-(.+)-.+","\\1"))
  input_df <- tibble::tibble(file=inputf,name=fnames,mark=mark,treatment=treatment,sample=sample)
  ## region <- 356L
  ## region_r <- ldetect_EUR[region]
  library(biomaRt)
  bm <- useMart(host="grch37.ensembl.org", biomart="ENSEMBL_MART_ENSEMBL", dataset="hsapiens_gene_ensembl")

  ## dTrack2 <- Gviz::DataTrack(range=x, genome="hg19", type="l", chromosome=paste0("chr",chromosomes(region_r)), name="bigwig")


  ## Gviz::plotTracks(dTrack2,from=starts(region_r),to=ends(region_r))
  focus_gr <- function(ldmr){
    chrp  <- paste0("chr",chromosomes(ldmr))
    start <- starts(ldmr)
    end <- ends(ldmr)

    return(GenomicRanges::GRanges(seqnames = chrp,ranges=IRanges::IRanges(start = start,end = end)))
  }

  region_r <- ldetect_EUR[512]
  gr <- focus_gr(region_r)
  sn <- as.character(seqnames(gr))
  biomTrack <- BiomartGeneRegionTrack(genome="hg19", chromosome=sn,start=starts(region_r),end=ends(region_r),geneSymbols=TRUE,name="ENSEMBL", filter=list(with_refseq_mrna=TRUE),biomart=bm,stacking="squish")

  top2 <- filter(pip_df, pip_model == max(pip_model))


  igrf <- function(tdf,ty){
    tyd <- ty$treatment
    inpl <- purrr::pmap(tdf, function(file, name, sample, ...){
      rtracklayer::import(file, which = gr)
    }) %>% plyranges::bind_regions() %>% disjoin_regions(score=mean(score)) 
    inpl %>% tibble::as_tibble() %>%
      dplyr::rename({{tyd}} := score) %>% 
      plyranges::as_granges()
  }

  ngrf <- function(idf,y, ...){
    rrangel <- group_by(idf,treatment) %>%
      group_map(igrf)  %>%  purrr::reduce(join_overlap_inner)
    dtrack <- Gviz::DataTrack(rrangel,groups=c("dec","unt"),name=glue::glue("{y$mark}"),type="hist",window=-1,windowSize=1500)
  }

  idf <- dplyr::filter(input_df,mark==mark[1])
  tdf <- filter(idf,treatment==treatment[1])
  rangel <- group_by(input_df,mark) %>% group_map(ngrf)

  trackl <- c(biomTrack,rangel)
  strt <- positions(top2$snp_struct)
  grangel <- HighlightTrack(trackl,chromosome=sn,start=strt,width=10)
  png(file="/home/nwknoblauch/Dropbox/Hand2.png")
  plotTracks(c(grangel),chromosome=sn,from=starts(region_r),to=ends(region_r))
  dev.off()

  GeneRegionTrack(txdb)
  rangeld <- lapply(rangel,function(df){
    mrk <- df$mark[1]
    df <- plyranges::select(df,-mark)
 
  })

    rangeldf <- bind_regions(rangel)


  plotTracks(rangeld,groups=c("DSC1","DSC2","DSC3"),type=c("a","p"))






  as_grange_df <- function(df, ...) {
    rl <- rlang::list2(...)
    explode_ldmap_region(df) %>%
      dplyr::rename(seqnames = chrom) %>%
      mutate(seqnames = as.character(seqnames)) %>%
      mutate(!!!rl) %>%
      plyranges::as_granges()
  }

  as_ldmr <- function(df) {
    tibble::as_tibble(df) %>%
      dplyr::mutate(seqnames = as.integer(stringr::str_remove(seqnames,"chr"))) %>% 
dplyr::select(-width) %>% 
      compact_ldmap_region(chrom = "seqnames")
  }


  read_df <- as_ldmr(ranged) %>% dplyr::select(-strand)
  pread_df <- tidyr::pivot_wider(read_df,names_from=c("mark","sample","treatment"),values_from=c("score"))
  ldmdf <- as_ldmr(out.gr)
#+END_SRC


#+BEGIN_SRC shell 

rsync -av rcc2:/project2/xinhe/software/ldsc/workflow/results ../workflow/results
#+END_SRC

#+RESULTS:
| receiving                                        | incremental | file                | list      |           |       |            |           |
| created                                          | directory   | ../workflow/results |           |           |       |            |           |
| results/                                         |             |                     |           |           |       |            |           |
| results/fgd/                                     |             |                     |           |           |       |            |           |
| results/fgd/clean_reproduciblemerged.log         |             |                     |           |           |       |            |           |
| results/fgd/clean_reproduciblemerged.results     |             |                     |           |           |       |            |           |
| results/fgd/clean_reproduciblemergedcsmc.log     |             |                     |           |           |       |            |           |
| results/fgd/clean_reproduciblemergedcsmc.results |             |                     |           |           |       |            |           |
| results/fgd/full_reproduciblemerged.log          |             |                     |           |           |       |            |           |
| results/fgd/full_reproduciblemerged.results      |             |                     |           |           |       |            |           |
| results/fgd/full_reproduciblemergedcsmc.log      |             |                     |           |           |       |            |           |
| results/fgd/full_reproduciblemergedcsmc.results  |             |                     |           |           |       |            |           |
| results/fgd/reproducible_merged.log              |             |                     |           |           |       |            |           |
| results/fgd/reproducible_merged.results          |             |                     |           |           |       |            |           |
| results/fgd/reproducible_up_down.log             |             |                     |           |           |       |            |           |
| results/fgd/reproducible_up_down.results         |             |                     |           |           |       |            |           |
| results/plot/                                    |             |                     |           |           |       |            |           |
| results/plot/LD/                                 |             |                     |           |           |       |            |           |
| results/plot/LD/15.RDS                           |             |                     |           |           |       |            |           |
| results/plot_data/                               |             |                     |           |           |       |            |           |
| results/plot_data/LD/                            |             |                     |           |           |       |            |           |
| results/plot_data/LD/15.RDS                      |             |                     |           |           |       |            |           |
| results/plot_data/anno/                          |             |                     |           |           |       |            |           |
| results/plot_data/anno/allhic_15.RDS             |             |                     |           |           |       |            |           |
| results/plot_data/anno/allhic_181.RDS            |             |                     |           |           |       |            |           |
| results/plot_data/anno/allhic_353.RDS            |             |                     |           |           |       |            |           |
| results/plot_data/anno/allhic_356.RDS            |             |                     |           |           |       |            |           |
| results/plot_data/anno/allhic_362.RDS            |             |                     |           |           |       |            |           |
| results/plot_data/anno/allhic_363.RDS            |             |                     |           |           |       |            |           |
| results/plot_data/anno/allhic_373.RDS            |             |                     |           |           |       |            |           |
| results/plot_data/anno/allhic_512.RDS            |             |                     |           |           |       |            |           |
| results/plot_data/anno/allhic_614.RDS            |             |                     |           |           |       |            |           |
| results/plot_data/anno/allhic_973.RDS            |             |                     |           |           |       |            |           |
| results/plot_data/genes/                         |             |                     |           |           |       |            |           |
| results/plot_data/genes/15.RDS                   |             |                     |           |           |       |            |           |
| results/plot_data/genes/15_genelist.txt.gz       |             |                     |           |           |       |            |           |
| results/plot_data/genes/181.RDS                  |             |                     |           |           |       |            |           |
| results/plot_data/genes/181_genelist.txt.gz      |             |                     |           |           |       |            |           |
| results/plot_data/genes/353.RDS                  |             |                     |           |           |       |            |           |
| results/plot_data/genes/353_genelist.txt.gz      |             |                     |           |           |       |            |           |
| results/plot_data/genes/356.RDS                  |             |                     |           |           |       |            |           |
| results/plot_data/genes/356_genelist.txt.gz      |             |                     |           |           |       |            |           |
| results/plot_data/genes/362.RDS                  |             |                     |           |           |       |            |           |
| results/plot_data/genes/362_genelist.txt.gz      |             |                     |           |           |       |            |           |
| results/plot_data/genes/363.RDS                  |             |                     |           |           |       |            |           |
| results/plot_data/genes/363_genelist.txt.gz      |             |                     |           |           |       |            |           |
| results/plot_data/genes/373.RDS                  |             |                     |           |           |       |            |           |
| results/plot_data/genes/373_genelist.txt.gz      |             |                     |           |           |       |            |           |
| results/plot_data/genes/512.RDS                  |             |                     |           |           |       |            |           |
| results/plot_data/genes/512_genelist.txt.gz      |             |                     |           |           |       |            |           |
| results/plot_data/genes/614.RDS                  |             |                     |           |           |       |            |           |
| results/plot_data/genes/614_genelist.txt.gz      |             |                     |           |           |       |            |           |
| results/plot_data/genes/973.RDS                  |             |                     |           |           |       |            |           |
| results/plot_data/genes/973_genelist.txt.gz      |             |                     |           |           |       |            |           |
| results/plot_data/hic/                           |             |                     |           |           |       |            |           |
| results/plot_data/hic/15.RDS                     |             |                     |           |           |       |            |           |
| results/plot_data/hic/181.RDS                    |             |                     |           |           |       |            |           |
| results/plot_data/hic/353.RDS                    |             |                     |           |           |       |            |           |
| results/plot_data/hic/356.RDS                    |             |                     |           |           |       |            |           |
| results/plot_data/hic/362.RDS                    |             |                     |           |           |       |            |           |
| results/plot_data/hic/363.RDS                    |             |                     |           |           |       |            |           |
| results/plot_data/hic/373.RDS                    |             |                     |           |           |       |            |           |
| results/plot_data/hic/512.RDS                    |             |                     |           |           |       |            |           |
| results/plot_data/hic/614.RDS                    |             |                     |           |           |       |            |           |
| results/plot_data/hic/973.RDS                    |             |                     |           |           |       |            |           |
| results/plot_data/susie/                         |             |                     |           |           |       |            |           |
| results/plot_data/susie/ptb_allhic_15.RDS        |             |                     |           |           |       |            |           |
| results/plot_data/susie/ptb_allhic_181.RDS       |             |                     |           |           |       |            |           |
| results/plot_data/susie/ptb_allhic_353.RDS       |             |                     |           |           |       |            |           |
| results/plot_data/susie/ptb_allhic_356.RDS       |             |                     |           |           |       |            |           |
| results/plot_data/susie/ptb_allhic_362.RDS       |             |                     |           |           |       |            |           |
| results/plot_data/susie/ptb_allhic_363.RDS       |             |                     |           |           |       |            |           |
| results/plot_data/susie/ptb_allhic_373.RDS       |             |                     |           |           |       |            |           |
| results/plot_data/susie/ptb_allhic_512.RDS       |             |                     |           |           |       |            |           |
| results/plot_data/susie/ptb_allhic_614.RDS       |             |                     |           |           |       |            |           |
| results/ptb/                                     |             |                     |           |           |       |            |           |
| results/ptb/clean_reproduciblemerged.log         |             |                     |           |           |       |            |           |
| results/ptb/clean_reproduciblemerged.results     |             |                     |           |           |       |            |           |
| results/ptb/clean_reproduciblemergedcsmc.log     |             |                     |           |           |       |            |           |
| results/ptb/clean_reproduciblemergedcsmc.results |             |                     |           |           |       |            |           |
| results/ptb/full_reproduciblemerged.log          |             |                     |           |           |       |            |           |
| results/ptb/full_reproduciblemerged.results      |             |                     |           |           |       |            |           |
| results/ptb/full_reproduciblemergedcsmc.log      |             |                     |           |           |       |            |           |
| results/ptb/full_reproduciblemergedcsmc.results  |             |                     |           |           |       |            |           |
| results/ptb/reproducible_merged.log              |             |                     |           |           |       |            |           |
| results/ptb/reproducible_merged.results          |             |                     |           |           |       |            |           |
| results/ptb/reproducible_up_down.log             |             |                     |           |           |       |            |           |
| results/ptb/reproducible_up_down.results         |             |                     |           |           |       |            |           |
|                                                  |             |                     |           |           |       |            |           |
| sent                                             | 1,480       | bytes               | received  | 8,011,197 | bytes | 942,667.88 | bytes/sec |
| total                                            | size        | is                  | 8,005,117 | speedup   | is    |        1.0 |           |



*** eQTL mapping

#+BEGIN_SRC snakemake :mkdirp :tangle ../workflow/eqtl_snakefile

  rule gwas_h52torus:
      input:
          inputf=config_d['GENO']
          snplist = expand(config_d['1KG'] +"1000G_EUR_Phase3_plink/1000G.EUR.QC.{chrom}.bim",chrom=range(1,23))
      output:
          outputf=config_d['GWAS'] +"{gwas}_torus.txt.gz"
      conda:
          config_e['r']
      script:
          "../scripts/gen_torus_sumstats.R"


#+END_SRC

